<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.0">
  <compounddef id="parser_8c" kind="file">
    <compoundname>parser.c</compoundname>
    <includes refid="tools_2lci_2lciframework_2parser_8h" local="yes">parser.h</includes>
    <incdepgraph>
      <node id="784">
        <label>stdlib.h</label>
      </node>
      <node id="788">
        <label>lexer.h</label>
        <link refid="lexer_8h"/>
        <childnode refid="784" relation="include">
        </childnode>
        <childnode refid="785" relation="include">
        </childnode>
        <childnode refid="786" relation="include">
        </childnode>
        <childnode refid="789" relation="include">
        </childnode>
      </node>
      <node id="787">
        <label>tokenizer.h</label>
        <link refid="tokenizer_8h"/>
        <childnode refid="784" relation="include">
        </childnode>
        <childnode refid="785" relation="include">
        </childnode>
        <childnode refid="786" relation="include">
        </childnode>
        <childnode refid="788" relation="include">
        </childnode>
      </node>
      <node id="786">
        <label>string.h</label>
      </node>
      <node id="789">
        <label>ctype.h</label>
      </node>
      <node id="782">
        <label>tools/lci/lciframework/parser.c</label>
        <link refid="parser.c"/>
        <childnode refid="783" relation="include">
        </childnode>
      </node>
      <node id="783">
        <label>parser.h</label>
        <link refid="tools_2lci_2lciframework_2parser_8h_source"/>
        <childnode refid="784" relation="include">
        </childnode>
        <childnode refid="785" relation="include">
        </childnode>
        <childnode refid="786" relation="include">
        </childnode>
        <childnode refid="787" relation="include">
        </childnode>
      </node>
      <node id="785">
        <label>stdio.h</label>
      </node>
    </incdepgraph>
      <sectiondef kind="func">
      <memberdef kind="function" id="parser_8c_1a7ef561f49b3072b116c95ac2c5814c7e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_main_node" kindref="compound">MainNode</ref> *</type>
        <definition>MainNode* createMainNode</definition>
        <argsstring>(BlockNode *block, FunctionTable *functab)</argsstring>
        <name>createMainNode</name>
        <param>
          <type><ref refid="struct_block_node" kindref="compound">BlockNode</ref> *</type>
          <declname>block</declname>
          <briefdescription><para>[in] A pointer to the block of code to execute first. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_function_table" kindref="compound">FunctionTable</ref> *</type>
          <declname>functab</declname>
          <briefdescription><para>[in] A pointer to the function table associated with this block of code. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a <ref refid="struct_main_node" kindref="compound">MainNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>block</emphasis> was created by createBlockNode(StmtNodeList *). </para><simplesectsep/><para><emphasis>functab</emphasis> was created by createFunctionTable(void) and contains items added by addFuncDefStmtNode(FunctionTable *, FuncDefStmtNode *).</para></simplesect>
<simplesect kind="return"><para>A pointer to a <ref refid="struct_main_node" kindref="compound">MainNode</ref> structure with the desired properties.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deleteMainNode(MainNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="29" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="27" bodyend="38"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a98ef10336ddfedf438488084f3dcfcac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void deleteMainNode</definition>
        <argsstring>(MainNode *node)</argsstring>
        <name>deleteMainNode</name>
        <param>
          <type><ref refid="struct_main_node" kindref="compound">MainNode</ref> *</type>
          <declname>node</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_main_node" kindref="compound">MainNode</ref> structure to be deleted. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Deletes a <ref refid="struct_main_node" kindref="compound">MainNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>node</emphasis> was created by createMainNode(BlockNode *, FunctionTable *).</para></simplesect>
<simplesect kind="post"><para>The memory at <emphasis>node</emphasis> and any of its associated members will be freed.</para></simplesect>
<simplesect kind="see"><para>createMainNode(BlockNode *, FunctionTable *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="49" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="48" bodyend="54"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1af4c48c1dad7430a58c5b223b89a866f7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_block_node" kindref="compound">BlockNode</ref> *</type>
        <definition>BlockNode* createBlockNode</definition>
        <argsstring>(StmtNodeList *stmts)</argsstring>
        <name>createBlockNode</name>
        <param>
          <type><ref refid="struct_stmt_node_list" kindref="compound">StmtNodeList</ref> *</type>
          <declname>stmts</declname>
          <briefdescription><para>[in] A pointer to the list of statements which comprise the block of code. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a <ref refid="struct_block_node" kindref="compound">BlockNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>stmts</emphasis> was created by createStmtNodeList(void) and contains contents added by addStmtNode(StmtNodeList *, StmtNode *).</para></simplesect>
<simplesect kind="return"><para>A pointer to a <ref refid="struct_block_node" kindref="compound">BlockNode</ref> structure with the desired properties.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deleteBlockNode(BlockNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="67" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="66" bodyend="75"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a612de62da711fab7d1996a796f23fd8f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void deleteBlockNode</definition>
        <argsstring>(BlockNode *node)</argsstring>
        <name>deleteBlockNode</name>
        <param>
          <type><ref refid="struct_block_node" kindref="compound">BlockNode</ref> *</type>
          <declname>node</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_block_node" kindref="compound">BlockNode</ref> structure to be deleted. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Deletes a <ref refid="struct_block_node" kindref="compound">BlockNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>node</emphasis> was created by createBlockNode(StmtNodeList *).</para></simplesect>
<simplesect kind="post"><para>The memory at <emphasis>node</emphasis> and any of its associated members will be freed.</para></simplesect>
<simplesect kind="see"><para>createBlockNode(StmtNodeList *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="86" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="85" bodyend="90"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a6fd5021f338c03f9ad6a5b0707c0e0db" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_block_node_list" kindref="compound">BlockNodeList</ref> *</type>
        <definition>BlockNodeList* createBlockNodeList</definition>
        <argsstring>(void)</argsstring>
        <name>createBlockNodeList</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a <ref refid="struct_block_node_list" kindref="compound">BlockNodeList</ref> structure.</para><para><simplesect kind="return"><para>A pointer to a <ref refid="struct_block_node_list" kindref="compound">BlockNodeList</ref> structure with the desired properties.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deleteBlockNodeList(BlockNodeList *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="100" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="99" bodyend="109"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1af4d3a2bf72c05430582a42601c99d5d8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_block_node" kindref="compound">BlockNode</ref> *</type>
        <definition>BlockNode* addBlockNode</definition>
        <argsstring>(BlockNodeList *list, BlockNode *node)</argsstring>
        <name>addBlockNode</name>
        <param>
          <type><ref refid="struct_block_node_list" kindref="compound">BlockNodeList</ref> *</type>
          <declname>list</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_block_node_list" kindref="compound">BlockNodeList</ref> structure to add <emphasis>node</emphasis> to. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_block_node" kindref="compound">BlockNode</ref> *</type>
          <declname>node</declname>
          <briefdescription><para>[in] A pointer to the <ref refid="struct_block_node" kindref="compound">BlockNode</ref> structure to add to <emphasis>list</emphasis>. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Adds a <ref refid="struct_block_node" kindref="compound">BlockNode</ref> structure to a <ref refid="struct_block_node_list" kindref="compound">BlockNodeList</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>list</emphasis> was created by createBlockNodeList(void). </para><simplesectsep/><para><emphasis>node</emphasis> was created by createBlockNode(StmtNodeList *).</para></simplesect>
<simplesect kind="post"><para><emphasis>node</emphasis> will be added on to the end of <emphasis>list</emphasis> and the size of <emphasis>list</emphasis> will be updated accordingly.</para></simplesect>
<simplesect kind="return"><para>A pointer to the added <ref refid="struct_block_node" kindref="compound">BlockNode</ref> structure (will be the same as <emphasis>node</emphasis>).</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>realloc was unable to allocate memory. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="124" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="122" bodyend="135"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a172268426b294758732c50381c4e0b8a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void deleteBlockNodeList</definition>
        <argsstring>(BlockNodeList *list)</argsstring>
        <name>deleteBlockNodeList</name>
        <param>
          <type><ref refid="struct_block_node_list" kindref="compound">BlockNodeList</ref> *</type>
          <declname>list</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_block_node_list" kindref="compound">BlockNodeList</ref> structure to delete. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Deletes a <ref refid="struct_block_node_list" kindref="compound">BlockNodeList</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>list</emphasis> was created by createBlockNodeList(void) and contains items added by addBlockNode(BlockNodeList *, BlockNode *).</para></simplesect>
<simplesect kind="post"><para>The memory at <emphasis>list</emphasis> and any of its associated members will be freed.</para></simplesect>
<simplesect kind="see"><para>createBlockNodeList(void) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="147" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="146" bodyend="154"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a1555a1eeb0a82afd310516014b8c86bb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_constant_node" kindref="compound">ConstantNode</ref> *</type>
        <definition>ConstantNode* createBooleanConstantNode</definition>
        <argsstring>(int data)</argsstring>
        <name>createBooleanConstantNode</name>
        <param>
          <type>int</type>
          <declname>data</declname>
          <briefdescription><para>[in] The constant boolean data. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a boolean type <ref refid="struct_constant_node" kindref="compound">ConstantNode</ref> structure.</para><para><simplesect kind="return"><para>A pointer to a boolean type <ref refid="struct_constant_node" kindref="compound">ConstantNode</ref> structure with value <computeroutput>0</computeroutput> if <emphasis>data</emphasis> equals 0 and <computeroutput>1</computeroutput> otherwise.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deleteConstantNode(ConstantNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="165" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="164" bodyend="174"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a8b7cff9d484e68622b2f57ea8be71845" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_constant_node" kindref="compound">ConstantNode</ref> *</type>
        <definition>ConstantNode* createIntegerConstantNode</definition>
        <argsstring>(int data)</argsstring>
        <name>createIntegerConstantNode</name>
        <param>
          <type>int</type>
          <declname>data</declname>
          <briefdescription><para>[in] The constant integer data. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates an integer type <ref refid="struct_constant_node" kindref="compound">ConstantNode</ref> structure.</para><para><simplesect kind="return"><para>A pointer to an integer type <ref refid="struct_constant_node" kindref="compound">ConstantNode</ref> storing the desired value.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deleteConstantNode(ConstantNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="184" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="183" bodyend="193"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a9cd100153967eac91900fe0d02c17d5e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_constant_node" kindref="compound">ConstantNode</ref> *</type>
        <definition>ConstantNode* createFloatConstantNode</definition>
        <argsstring>(float data)</argsstring>
        <name>createFloatConstantNode</name>
        <param>
          <type>float</type>
          <declname>data</declname>
          <briefdescription><para>[in] The constant floating point decimal data. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a floating point decimal type <ref refid="struct_constant_node" kindref="compound">ConstantNode</ref> structure.</para><para><simplesect kind="return"><para>A pointer to a floating point decimal type <ref refid="struct_constant_node" kindref="compound">ConstantNode</ref> storing the desired value.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deleteConstantNode(ConstantNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="204" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="203" bodyend="213"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a9eab00d42b70a4da965f646a4b8c0711" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_constant_node" kindref="compound">ConstantNode</ref> *</type>
        <definition>ConstantNode* createStringConstantNode</definition>
        <argsstring>(char *data)</argsstring>
        <name>createStringConstantNode</name>
        <param>
          <type>char *</type>
          <declname>data</declname>
          <briefdescription><para>[in] The constant character string data. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a string type <ref refid="struct_constant_node" kindref="compound">ConstantNode</ref> structure.</para><para><simplesect kind="return"><para>A pointer to a string type <ref refid="struct_constant_node" kindref="compound">ConstantNode</ref> storing the desired value.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deleteConstantNode(ConstantNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="223" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="222" bodyend="232"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1ab95d800ea8ea87ace54b9418c899c804" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void deleteConstantNode</definition>
        <argsstring>(ConstantNode *node)</argsstring>
        <name>deleteConstantNode</name>
        <param>
          <type><ref refid="struct_constant_node" kindref="compound">ConstantNode</ref> *</type>
          <declname>node</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_constant_node" kindref="compound">ConstantNode</ref> structure to be deleted. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Deletes a <ref refid="struct_constant_node" kindref="compound">ConstantNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>node</emphasis> was created by either createBooleanConstantNode(int), createIntegerConstantNode(int), createFloatConstantNode(float), or createStringConstantNode(char *).</para></simplesect>
<simplesect kind="post"><para>The memory at <emphasis>node</emphasis> and any of its associated members will be freed.</para></simplesect>
<simplesect kind="see"><para>createBooleanConstantNode(int) </para><simplesectsep/><para>createIntegerConstantNode(int) </para><simplesectsep/><para>createFloatConstantNode(float) </para><simplesectsep/><para>createStringConstantNode(char *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="247" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="246" bodyend="251"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a166f82a285797494cdc98723535f1a96" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> *</type>
        <definition>IdentifierNode* createIdentifierNode</definition>
        <argsstring>(char *image, const char *fname, unsigned int line)</argsstring>
        <name>createIdentifierNode</name>
        <param>
          <type>char *</type>
          <declname>image</declname>
          <briefdescription><para>[in] An array of characters that name the identifier. </para></briefdescription>
        </param>
        <param>
          <type>const char *</type>
          <declname>fname</declname>
          <briefdescription><para>[in] A pointer to the name of the file containing the identifier. </para></briefdescription>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>line</declname>
          <briefdescription><para>[in] The line number from the source file that the identifier occurred on. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates an <ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> structure.</para><para><simplesect kind="note"><para><emphasis>image</emphasis> is <bold>copied</bold> for use within the structure so it must be freed by the caller.</para></simplesect>
<simplesect kind="return"><para>A pointer to an <ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> structure with the desired properties.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deleteIdentifierNode(IdentifierNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="267" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="264" bodyend="283"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a96f079b292f54897920d07e0e3f59b88" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void deleteIdentifierNode</definition>
        <argsstring>(IdentifierNode *node)</argsstring>
        <name>deleteIdentifierNode</name>
        <param>
          <type><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> *</type>
          <declname>node</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> structure to be deleted. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Deletes an <ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>node</emphasis> was created by createIdentifierNode(char *, const char *, unsigned int).</para></simplesect>
<simplesect kind="post"><para>The memory at <emphasis>node</emphasis> and any of its associated members will be freed.</para></simplesect>
<simplesect kind="see"><para>createIdentifierNode(char *, const char *, unsigned int) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="294" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="293" bodyend="298"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a071185a9419aa55306ef21a2b51a6c0c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_identifier_node_list" kindref="compound">IdentifierNodeList</ref> *</type>
        <definition>IdentifierNodeList* createIdentifierNodeList</definition>
        <argsstring>(void)</argsstring>
        <name>createIdentifierNodeList</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates an <ref refid="struct_identifier_node_list" kindref="compound">IdentifierNodeList</ref> structure.</para><para><simplesect kind="return"><para>A pointer to a <ref refid="struct_identifier_node_list" kindref="compound">IdentifierNodeList</ref> structure with the desired properties.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deleteIdentifierNodeList(IdentifierNodeList *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="309" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="308" bodyend="318"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a4a7142d94786ab349f4a26b496f37b15" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> *</type>
        <definition>IdentifierNode* addIdentifierNode</definition>
        <argsstring>(IdentifierNodeList *list, IdentifierNode *node)</argsstring>
        <name>addIdentifierNode</name>
        <param>
          <type><ref refid="struct_identifier_node_list" kindref="compound">IdentifierNodeList</ref> *</type>
          <declname>list</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_identifier_node_list" kindref="compound">IdentifierNodeList</ref> structure to add <emphasis>node</emphasis> to. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> *</type>
          <declname>node</declname>
          <briefdescription><para>[in] A pointer to the <ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> structure to add to <emphasis>list</emphasis>. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Adds an <ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> structure to an <ref refid="struct_identifier_node_list" kindref="compound">IdentifierNodeList</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>list</emphasis> was created by createIdentifierNodeList(void). </para><simplesectsep/><para><emphasis>node</emphasis> was created by createIdentifierNode(char *, const char *, unsigned int).</para></simplesect>
<simplesect kind="post"><para><emphasis>node</emphasis> will be added on to the end of <emphasis>list</emphasis> and the size of <emphasis>list</emphasis> will be updated accordingly.</para></simplesect>
<simplesect kind="return"><para>A pointer to the added <ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> structure (will be the same as <emphasis>node</emphasis>).</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>realloc was unable to allocate memory. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="334" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="332" bodyend="345"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a0981294f5b54e2daaa5b007cccdaab10" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void deleteIdentifierNodeList</definition>
        <argsstring>(IdentifierNodeList *list)</argsstring>
        <name>deleteIdentifierNodeList</name>
        <param>
          <type><ref refid="struct_identifier_node_list" kindref="compound">IdentifierNodeList</ref> *</type>
          <declname>list</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_identifier_node_list" kindref="compound">IdentifierNodeList</ref> structure to delete. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Deletes an <ref refid="struct_identifier_node_list" kindref="compound">IdentifierNodeList</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>list</emphasis> was created by createIdentifierNodeList(void) and contains items added by addIdentifierNode(IdentifierNodeList *, IdentifierNode *).</para></simplesect>
<simplesect kind="post"><para>The memory at <emphasis>list</emphasis> and any of its associated members will be freed.</para></simplesect>
<simplesect kind="see"><para>createIdentifierNodeList(void) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="357" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="356" bodyend="364"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a33cdfe250d86d923adf96777bd63a9ec" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_type_node" kindref="compound">TypeNode</ref> *</type>
        <definition>TypeNode* createTypeNode</definition>
        <argsstring>(ConstantType type)</argsstring>
        <name>createTypeNode</name>
        <param>
          <type>ConstantType</type>
          <declname>type</declname>
          <briefdescription><para>[in] The type of value. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a <ref refid="struct_type_node" kindref="compound">TypeNode</ref> structure.</para><para><simplesect kind="return"><para>A pointer to a <ref refid="struct_type_node" kindref="compound">TypeNode</ref> structure with the desired properties.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deleteTypeNode(TypeNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="374" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="373" bodyend="382"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a0cdee82cef1017fcd4d92bb7393eacb4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void deleteTypeNode</definition>
        <argsstring>(TypeNode *node)</argsstring>
        <name>deleteTypeNode</name>
        <param>
          <type><ref refid="struct_type_node" kindref="compound">TypeNode</ref> *</type>
          <declname>node</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_type_node" kindref="compound">TypeNode</ref> structure to be deleted. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Deletes a <ref refid="struct_type_node" kindref="compound">TypeNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>node</emphasis> was created by createTypeNode(ConstantType).</para></simplesect>
<simplesect kind="post"><para>The memory at <emphasis>node</emphasis> and any of its associated members will be freed.</para></simplesect>
<simplesect kind="see"><para>createTypeNode(ConstantType) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="393" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="392" bodyend="396"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a9f425cb8f8c892a4941673598deea1fe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_stmt_node" kindref="compound">StmtNode</ref> *</type>
        <definition>StmtNode* createStmtNode</definition>
        <argsstring>(StmtType type, void *stmt)</argsstring>
        <name>createStmtNode</name>
        <param>
          <type>StmtType</type>
          <declname>type</declname>
          <briefdescription><para>[in] The type of statement stored in <emphasis>node</emphasis>. </para></briefdescription>
        </param>
        <param>
          <type>void *</type>
          <declname>stmt</declname>
          <briefdescription><para>[in] A pointer to the particular statement structure. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a <ref refid="struct_stmt_node" kindref="compound">StmtNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>stmt</emphasis> contains a structure created corresponding to <emphasis>type:</emphasis> <itemizedlist>
<listitem><para>ST_CAST: createCastStmtNode(IdentifierNode *, TypeNode *)</para></listitem><listitem><para>ST_PRINT: createPrintStmtNode(ExprNodeList *, int)</para></listitem><listitem><para>ST_INPUT: createInputStmtNode(IdentifierNode *)</para></listitem><listitem><para>ST_ASSIGNMENT: createAssignmentStmtNode(IdentifierNode *, ExprNode *)</para></listitem><listitem><para>ST_DECLARATION: createDeclarationStmtNode(IdentifierNode *, IdentifierNode *, ExprNode *)</para></listitem><listitem><para>ST_IFTHENELSE: createIfThenElseStmtNode(BlockNode *, BlockNode *, ExprNodeList *, BlockNodeList *)</para></listitem><listitem><para>ST_SWITCH: createSwitchStmtNode(ExprNodeList *, BlockNodeList *, BlockNode *)</para></listitem><listitem><para>ST_BREAK: no structure needed, use <computeroutput>NULL</computeroutput> </para></listitem><listitem><para>ST_RETURN: createReturnStmtNode(ExprNode *)</para></listitem><listitem><para>ST_LOOP: createLoopStmtNode(IdentifierNode *, IdentifierNode *, ExprNode *, ExprNode *, BlockNode *)</para></listitem><listitem><para>ST_FUNCDEF: createFuncDefStmtNode(IdentifierNode *, IdentifierNode *, IdentifierNodeList *, BlockNode *)</para></listitem><listitem><para>ST_EXPR: createExprNode(ExprType, void *)</para></listitem></itemizedlist>
</para></simplesect>
<simplesect kind="return"><para>A pointer to a <ref refid="struct_stmt_node" kindref="compound">StmtNode</ref> structure with the desired properties.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deleteStmtNode(StmtNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="421" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="419" bodyend="430"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1aebbf8222e30b610b62cec46862e5232f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void deleteStmtNode</definition>
        <argsstring>(StmtNode *node)</argsstring>
        <name>deleteStmtNode</name>
        <param>
          <type><ref refid="struct_stmt_node" kindref="compound">StmtNode</ref> *</type>
          <declname>node</declname>
          <briefdescription><para>[in, out] A pointer to the <ref refid="struct_stmt_node" kindref="compound">StmtNode</ref> structure to be deleted. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Deletes a <ref refid="struct_stmt_node" kindref="compound">StmtNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>node</emphasis> was created by createStmtNode(StmtType, void *).</para></simplesect>
<simplesect kind="post"><para>The memory at <emphasis>stmt</emphasis> and any of its associated members will be freed.</para></simplesect>
<simplesect kind="see"><para>createStmtNode(StmtType, void *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="441" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="440" bodyend="506"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a5387dc4eb63531315f26e6ad56edf0c6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_stmt_node_list" kindref="compound">StmtNodeList</ref> *</type>
        <definition>StmtNodeList* createStmtNodeList</definition>
        <argsstring>(void)</argsstring>
        <name>createStmtNodeList</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a <ref refid="struct_stmt_node_list" kindref="compound">StmtNodeList</ref> structure.</para><para><simplesect kind="return"><para>A pointer to a <ref refid="struct_stmt_node_list" kindref="compound">StmtNodeList</ref> structure with no elements.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deleteStmtNodeList(StmtNodeList *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="516" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="515" bodyend="525"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a9159ef2b5ad601357558ee1e4c609680" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_stmt_node" kindref="compound">StmtNode</ref> *</type>
        <definition>StmtNode* addStmtNode</definition>
        <argsstring>(StmtNodeList *list, StmtNode *node)</argsstring>
        <name>addStmtNode</name>
        <param>
          <type><ref refid="struct_stmt_node_list" kindref="compound">StmtNodeList</ref> *</type>
          <declname>list</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_stmt_node_list" kindref="compound">StmtNodeList</ref> structure to add <emphasis>node</emphasis> to. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_stmt_node" kindref="compound">StmtNode</ref> *</type>
          <declname>node</declname>
          <briefdescription><para>[in] A pointer to the <ref refid="struct_stmt_node" kindref="compound">StmtNode</ref> structure to add to <emphasis>list</emphasis>. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Adds a <ref refid="struct_stmt_node" kindref="compound">StmtNode</ref> to a <ref refid="struct_stmt_node_list" kindref="compound">StmtNodeList</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>list</emphasis> was created by createStmtNodeList(void). </para><simplesectsep/><para><emphasis>node</emphasis> was created by createStmtNode(StmtType, void *).</para></simplesect>
<simplesect kind="post"><para><emphasis>node</emphasis> will be added on to the end of <emphasis>list</emphasis> and the size of <emphasis>list</emphasis> will be updated accordingly.</para></simplesect>
<simplesect kind="return"><para>A pointer to the added <ref refid="struct_stmt_node" kindref="compound">StmtNode</ref> (will be the same as <emphasis>node</emphasis>).</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="540" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="538" bodyend="551"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a8f05e322e85bb18963d784f364dc1829" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void deleteStmtNodeList</definition>
        <argsstring>(StmtNodeList *list)</argsstring>
        <name>deleteStmtNodeList</name>
        <param>
          <type><ref refid="struct_stmt_node_list" kindref="compound">StmtNodeList</ref> *</type>
          <declname>list</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_stmt_node_list" kindref="compound">StmtNodeList</ref> structure to delete. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Deletes a <ref refid="struct_stmt_node_list" kindref="compound">StmtNodeList</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>list</emphasis> was created by createStmtNodeList(void) and contains items added by addStmtNode(StmtNodeList *, StmtNode *).</para></simplesect>
<simplesect kind="post"><para>The memory at <emphasis>list</emphasis> and any of its associated members will be freed.</para></simplesect>
<simplesect kind="see"><para>createStmtNodeList(void) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="563" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="562" bodyend="570"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1aac4756cdb1495bba9fc61848aabd9345" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_cast_stmt_node" kindref="compound">CastStmtNode</ref> *</type>
        <definition>CastStmtNode* createCastStmtNode</definition>
        <argsstring>(IdentifierNode *target, TypeNode *newtype)</argsstring>
        <name>createCastStmtNode</name>
        <param>
          <type><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> *</type>
          <declname>target</declname>
          <briefdescription><para>[in] A pointer to the name of the variable whose type is to be changed to <emphasis>newtype</emphasis>. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_type_node" kindref="compound">TypeNode</ref> *</type>
          <declname>newtype</declname>
          <briefdescription><para>[in] A pointer to the type to change <emphasis>target</emphasis> to. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a <ref refid="struct_cast_stmt_node" kindref="compound">CastStmtNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>target</emphasis> was created by createIdentifierNode(char *, const char *, unsigned int). </para><simplesectsep/><para><emphasis>newtype</emphasis> was created by createTypeNode(ConstantType).</para></simplesect>
<simplesect kind="return"><para>A pointer to a <ref refid="struct_cast_stmt_node" kindref="compound">CastStmtNode</ref> structure with the desired properties.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deleteCastStmtNode(CastStmtNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="584" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="582" bodyend="593"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a4a0b6ba43c4ac5d73c0c1adaef696a4a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void deleteCastStmtNode</definition>
        <argsstring>(CastStmtNode *node)</argsstring>
        <name>deleteCastStmtNode</name>
        <param>
          <type><ref refid="struct_cast_stmt_node" kindref="compound">CastStmtNode</ref> *</type>
          <declname>node</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_cast_stmt_node" kindref="compound">CastStmtNode</ref> structure to be deleted. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Deletes a <ref refid="struct_cast_stmt_node" kindref="compound">CastStmtNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>node</emphasis> was created by createCastStmtNode(IdentifierNode *, TypeNode *).</para></simplesect>
<simplesect kind="post"><para>The memory at <emphasis>node</emphasis> and any of its associated members will be freed.</para></simplesect>
<simplesect kind="see"><para>createCastStmtNode(IdentifierNode *, TypeNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="604" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="603" bodyend="609"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1af76ed854b8a37e1629a37ebcf23ae0cc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_print_stmt_node" kindref="compound">PrintStmtNode</ref> *</type>
        <definition>PrintStmtNode* createPrintStmtNode</definition>
        <argsstring>(ExprNodeList *args, int nonl)</argsstring>
        <name>createPrintStmtNode</name>
        <param>
          <type><ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref> *</type>
          <declname>args</declname>
          <briefdescription><para>[in] A pointer to the list of expressions to evaluate and print. </para></briefdescription>
        </param>
        <param>
          <type>int</type>
          <declname>nonl</declname>
          <briefdescription><para>[in] Denotes an ending newline should be surpressed if not <computeroutput>0</computeroutput> and printed if <computeroutput>0</computeroutput>. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a <ref refid="struct_print_stmt_node" kindref="compound">PrintStmtNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>args</emphasis> was created by createExprNodeList(void) and contains items added by addExprNode(ExprNodeList *, ExprNode *).</para></simplesect>
<simplesect kind="return"><para>A pointer to a <ref refid="struct_print_stmt_node" kindref="compound">PrintStmtNode</ref> structure with the desired properties.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deletePrintStmtNode(PrintStmtNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="623" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="621" bodyend="632"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1af1d7b92a63e7a7b05963d8195286c54c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void deletePrintStmtNode</definition>
        <argsstring>(PrintStmtNode *node)</argsstring>
        <name>deletePrintStmtNode</name>
        <param>
          <type><ref refid="struct_print_stmt_node" kindref="compound">PrintStmtNode</ref> *</type>
          <declname>node</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_print_stmt_node" kindref="compound">PrintStmtNode</ref> structure to be deleted. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Deletes a <ref refid="struct_print_stmt_node" kindref="compound">PrintStmtNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>node</emphasis> was created by createPrintStmtNode(ExprNodeList *, int).</para></simplesect>
<simplesect kind="post"><para>The memory at <emphasis>node</emphasis> and any of its associated members will be freed.</para></simplesect>
<simplesect kind="see"><para>createPrintStmtNode(ExprNodeList *, int) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="643" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="642" bodyend="647"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a2396ffcbc70e7b5b2314dc6c16cc7a68" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_input_stmt_node" kindref="compound">InputStmtNode</ref> *</type>
        <definition>InputStmtNode* createInputStmtNode</definition>
        <argsstring>(IdentifierNode *target)</argsstring>
        <name>createInputStmtNode</name>
        <param>
          <type><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> *</type>
          <declname>target</declname>
          <briefdescription><para>[in] A pointer to the name of the variable to store the input in. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates an <ref refid="struct_input_stmt_node" kindref="compound">InputStmtNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>target</emphasis> was created by createIdentifierNode(char *, const char *, unsigned int).</para></simplesect>
<simplesect kind="return"><para>A pointer to an <ref refid="struct_input_stmt_node" kindref="compound">InputStmtNode</ref> structure with the desired properties.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deleteInputStmtNode(InputStmtNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="659" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="658" bodyend="667"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a9caac52b9a18a5e98126c4e9707c2918" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void deleteInputStmtNode</definition>
        <argsstring>(InputStmtNode *node)</argsstring>
        <name>deleteInputStmtNode</name>
        <param>
          <type><ref refid="struct_input_stmt_node" kindref="compound">InputStmtNode</ref> *</type>
          <declname>node</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_input_stmt_node" kindref="compound">InputStmtNode</ref> structure to be deleted. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Deletes an <ref refid="struct_input_stmt_node" kindref="compound">InputStmtNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>node</emphasis> was created by createInputStmtNode(IdentifierNode *).</para></simplesect>
<simplesect kind="post"><para>The memory at <emphasis>node</emphasis> and any of its associated members will be freed.</para></simplesect>
<simplesect kind="see"><para>createInputStmtNode(IdentifierNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="678" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="677" bodyend="682"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a359466584c0daa035e4f7277d44d8550" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_assignment_stmt_node" kindref="compound">AssignmentStmtNode</ref> *</type>
        <definition>AssignmentStmtNode* createAssignmentStmtNode</definition>
        <argsstring>(IdentifierNode *target, ExprNode *expr)</argsstring>
        <name>createAssignmentStmtNode</name>
        <param>
          <type><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> *</type>
          <declname>target</declname>
          <briefdescription><para>[in] A pointer to the name of the variable to store the evaluated contents of a <emphasis>expr</emphasis> into. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_expr_node" kindref="compound">ExprNode</ref> *</type>
          <declname>expr</declname>
          <briefdescription><para>[in] A pointer to the expression to evaluate and store in <emphasis>target</emphasis>. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates an <ref refid="struct_assignment_stmt_node" kindref="compound">AssignmentStmtNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>target</emphasis> was created by createIdentifierNode(char *, const char *, unsigned int). </para><simplesectsep/><para><emphasis>expr</emphasis> was created by createExprNode(ExprType, void *).</para></simplesect>
<simplesect kind="return"><para>A pointer to an <ref refid="struct_assignment_stmt_node" kindref="compound">AssignmentStmtNode</ref> structure with the desired properties.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deleteAssignmentStmtNode(AssignmentStmtNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="697" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="695" bodyend="706"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a3a7f5dcbfc2015b2af2ffb94ff798578" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void deleteAssignmentStmtNode</definition>
        <argsstring>(AssignmentStmtNode *node)</argsstring>
        <name>deleteAssignmentStmtNode</name>
        <param>
          <type><ref refid="struct_assignment_stmt_node" kindref="compound">AssignmentStmtNode</ref> *</type>
          <declname>node</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_assignment_stmt_node" kindref="compound">AssignmentStmtNode</ref> structure to be deleted. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Deletes an <ref refid="struct_assignment_stmt_node" kindref="compound">AssignmentStmtNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>node</emphasis> was created by createAssignmentStmtNode(IdentifierNode *, ExprNode *).</para></simplesect>
<simplesect kind="post"><para>The memory at <emphasis>node</emphasis> and any of its associated members will be freed.</para></simplesect>
<simplesect kind="see"><para>createAssignmentStmtNode(IdentifierNode *, ExprNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="717" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="716" bodyend="722"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a91d01f9dddd9a396eeee1bccf6e903e9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_declaration_stmt_node" kindref="compound">DeclarationStmtNode</ref> *</type>
        <definition>DeclarationStmtNode* createDeclarationStmtNode</definition>
        <argsstring>(IdentifierNode *scope, IdentifierNode *target, ExprNode *expr)</argsstring>
        <name>createDeclarationStmtNode</name>
        <param>
          <type><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> *</type>
          <declname>scope</declname>
          <briefdescription><para>[in] A pointer to the scope to create the variable in. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> *</type>
          <declname>target</declname>
          <briefdescription><para>[in] A pointer to the name of the variable to create. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_expr_node" kindref="compound">ExprNode</ref> *</type>
          <declname>expr</declname>
          <briefdescription><para>[in] An optional pointer to the expression to initialize <emphasis>target</emphasis> to. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a <ref refid="struct_declaration_stmt_node" kindref="compound">DeclarationStmtNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>scope</emphasis> was created by createIdentifierNode(char *, const char *, unsigned int). </para><simplesectsep/><para><emphasis>target</emphasis> was created by createIdentifierNode(char *, const char *, unsigned int). </para><simplesectsep/><para><emphasis>expr</emphasis> was created by createExprNode(ExprType, void *).</para></simplesect>
<simplesect kind="return"><para>A pointer to a <ref refid="struct_declaration_stmt_node" kindref="compound">DeclarationStmtNode</ref> structure with the desired properties.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deleteDeclarationStmtNode(DeclarationStmtNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="739" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="736" bodyend="749"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1aac3232a5af64e872c317c62d11493f75" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void deleteDeclarationStmtNode</definition>
        <argsstring>(DeclarationStmtNode *node)</argsstring>
        <name>deleteDeclarationStmtNode</name>
        <param>
          <type><ref refid="struct_declaration_stmt_node" kindref="compound">DeclarationStmtNode</ref> *</type>
          <declname>node</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_declaration_stmt_node" kindref="compound">DeclarationStmtNode</ref> structure to be deleted. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Deletes a <ref refid="struct_declaration_stmt_node" kindref="compound">DeclarationStmtNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>node</emphasis> was created by createDeclarationStmtNode(IdentifierNode *, IdentifierNode *, ExprNode *).</para></simplesect>
<simplesect kind="post"><para>The memory at <emphasis>node</emphasis> and any of its associated members will be freed.</para></simplesect>
<simplesect kind="see"><para>createDeclarationStmtNode(IdentifierNode *, IdentifierNode *, ExprNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="760" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="759" bodyend="766"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a12f221df6b151291485323de52737fcc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_if_then_else_stmt_node" kindref="compound">IfThenElseStmtNode</ref> *</type>
        <definition>IfThenElseStmtNode* createIfThenElseStmtNode</definition>
        <argsstring>(BlockNode *yes, BlockNode *no, ExprNodeList *guards, BlockNodeList *blocks)</argsstring>
        <name>createIfThenElseStmtNode</name>
        <param>
          <type><ref refid="struct_block_node" kindref="compound">BlockNode</ref> *</type>
          <declname>yes</declname>
          <briefdescription><para>[in] A pointer to the block of code to execute if the <ref refid="impvar" kindref="compound">implicit variable</ref> casts to <computeroutput>false</computeroutput>. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_block_node" kindref="compound">BlockNode</ref> *</type>
          <declname>no</declname>
          <briefdescription><para>[in] A pointer to the block of code to execute if the <ref refid="impvar" kindref="compound">implicit variable</ref> casts to <computeroutput>false</computeroutput> <bold>and</bold> the evaluations of all of the <emphasis>guards</emphasis> cast to <computeroutput>false</computeroutput>. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref> *</type>
          <declname>guards</declname>
          <briefdescription><para>[in] A pointer to the expressions to test if the <ref refid="impvar" kindref="compound">implicit variable</ref> casts to <computeroutput>false</computeroutput>. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_block_node_list" kindref="compound">BlockNodeList</ref> *</type>
          <declname>blocks</declname>
          <briefdescription><para>[in] A pointer to the respective blocks of code to execute if one of the evaluated <emphasis>guards</emphasis> casts to <computeroutput>true</computeroutput>. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates an <ref refid="struct_if_then_else_stmt_node" kindref="compound">IfThenElseStmtNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>yes</emphasis> was created by createBlockNode(StmtNodeList *). </para><simplesectsep/><para><emphasis>no</emphasis> was created by createBlockNode(StmtNodeList *). </para><simplesectsep/><para><emphasis>guards</emphasis> was created by createExprNodeList(void) and contains items added by addExprNode(ExprNodeList *, ExprNode *). </para><simplesectsep/><para><emphasis>blocks</emphasis> was created by createBlockNodeList(void) and contains items added by addBlockNode(BlockNodeList *, BlockNode *).</para></simplesect>
<simplesect kind="return"><para>A pointer to a <ref refid="struct_if_then_else_stmt_node" kindref="compound">IfThenElseStmtNode</ref> structure with the desired properties.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deleteIfThenElseStmtNode(IfThenElseStmtNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="787" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="783" bodyend="798"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1acbd132c4c95ab2462015a804df4a89ed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void deleteIfThenElseStmtNode</definition>
        <argsstring>(IfThenElseStmtNode *node)</argsstring>
        <name>deleteIfThenElseStmtNode</name>
        <param>
          <type><ref refid="struct_if_then_else_stmt_node" kindref="compound">IfThenElseStmtNode</ref> *</type>
          <declname>node</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_if_then_else_stmt_node" kindref="compound">IfThenElseStmtNode</ref> structure to be deleted. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Deletes a <ref refid="struct_if_then_else_stmt_node" kindref="compound">IfThenElseStmtNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>node</emphasis> was created by createIfThenElseStmtNode(BlockNode *, BlockNode *, ExprNodeList *, BlockNodeList *).</para></simplesect>
<simplesect kind="post"><para>The memory at <emphasis>node</emphasis> and any of its associated members will be freed.</para></simplesect>
<simplesect kind="see"><para>createIfThenElseStmtNode(BlockNode *, BlockNode *, ExprNodeList *, BlockNodeList *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="809" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="808" bodyend="816"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a70a99b5a9938cc173f564064a0d4eaf5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_switch_stmt_node" kindref="compound">SwitchStmtNode</ref> *</type>
        <definition>SwitchStmtNode* createSwitchStmtNode</definition>
        <argsstring>(ExprNodeList *guards, BlockNodeList *blocks, BlockNode *def)</argsstring>
        <name>createSwitchStmtNode</name>
        <param>
          <type><ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref> *</type>
          <declname>guards</declname>
          <briefdescription><para>[in] A pointer to the expressions to evaluate and compare to the <ref refid="impvar" kindref="compound">implicit variable</ref>. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_block_node_list" kindref="compound">BlockNodeList</ref> *</type>
          <declname>blocks</declname>
          <briefdescription><para>[in] A pointer to the respective blocks of code to execute if one of the <emphasis>guards</emphasis> matches the <ref refid="impvar" kindref="compound">implicit variable</ref>. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_block_node" kindref="compound">BlockNode</ref> *</type>
          <declname>def</declname>
          <briefdescription><para>[in] A pointer to the default block of code to execute if none of the <emphasis>guards</emphasis> match the <ref refid="impvar" kindref="compound">implicit variable</ref>. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a <ref refid="struct_switch_stmt_node" kindref="compound">SwitchStmtNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>guards</emphasis> was created by createExprNodeList(void) and contains items added by addExprNode(ExprNodeList *, ExprNode *). </para><simplesectsep/><para><emphasis>blocks</emphasis> was created by createBlockNodeList(void) and contains items added by addBlockNode(BlockNodeList *, BlockNode *). </para><simplesectsep/><para><emphasis>def</emphasis> was created by createBlockNode(StmtNodeList *).</para></simplesect>
<simplesect kind="return"><para>A pointer to a <ref refid="struct_switch_stmt_node" kindref="compound">SwitchStmtNode</ref> structure with the desired properties.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deleteSwitchStmtNode(SwitchStmtNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="834" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="831" bodyend="844"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a2eaae2e2a53cd2635596e5ce8810aef2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void deleteSwitchStmtNode</definition>
        <argsstring>(SwitchStmtNode *node)</argsstring>
        <name>deleteSwitchStmtNode</name>
        <param>
          <type><ref refid="struct_switch_stmt_node" kindref="compound">SwitchStmtNode</ref> *</type>
          <declname>node</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_switch_stmt_node" kindref="compound">SwitchStmtNode</ref> structure to be deleted. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Deletes a <ref refid="struct_switch_stmt_node" kindref="compound">SwitchStmtNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>node</emphasis> was created by createSwitchStmtNode(ExprNodeList *, BlockNodeList *, BlockNode *).</para></simplesect>
<simplesect kind="post"><para>The memory at <emphasis>node</emphasis> and any of its associated members will be freed.</para></simplesect>
<simplesect kind="see"><para>createSwitchStmtNode(ExprNodeList *, BlockNodeList *, BlockNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="855" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="854" bodyend="861"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a1afd6ea39064c70835443ea4e29ce914" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_return_stmt_node" kindref="compound">ReturnStmtNode</ref> *</type>
        <definition>ReturnStmtNode* createReturnStmtNode</definition>
        <argsstring>(ExprNode *value)</argsstring>
        <name>createReturnStmtNode</name>
        <param>
          <type><ref refid="struct_expr_node" kindref="compound">ExprNode</ref> *</type>
          <declname>value</declname>
          <briefdescription><para>[in] A pointer to the value to return. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a <ref refid="struct_return_stmt_node" kindref="compound">ReturnStmtNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>value</emphasis> was created by createExprNode(ExprType, void *).</para></simplesect>
<simplesect kind="return"><para>A pointer to a <ref refid="struct_return_stmt_node" kindref="compound">ReturnStmtNode</ref> structure with the desired properties.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deleteReturnStmtNode(ReturnStmtNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="873" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="872" bodyend="881"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1af3190c617bce6238a272de3a3be58081" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void deleteReturnStmtNode</definition>
        <argsstring>(ReturnStmtNode *node)</argsstring>
        <name>deleteReturnStmtNode</name>
        <param>
          <type><ref refid="struct_return_stmt_node" kindref="compound">ReturnStmtNode</ref> *</type>
          <declname>node</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_return_stmt_node" kindref="compound">ReturnStmtNode</ref> structure to be deleted. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Deletes a <ref refid="struct_return_stmt_node" kindref="compound">ReturnStmtNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>node</emphasis> was created by createReturnStmtNode(ExprNode *).</para></simplesect>
<simplesect kind="post"><para>The memory at <emphasis>node</emphasis> and any of its associated members will be freed.</para></simplesect>
<simplesect kind="see"><para>createReturnStmtNode(ExprNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="892" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="891" bodyend="896"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a70fb88da6e4c3c70ce7e2250ec3bba0a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_loop_stmt_node" kindref="compound">LoopStmtNode</ref> *</type>
        <definition>LoopStmtNode* createLoopStmtNode</definition>
        <argsstring>(IdentifierNode *name, IdentifierNode *var, ExprNode *guard, ExprNode *update, BlockNode *body)</argsstring>
        <name>createLoopStmtNode</name>
        <param>
          <type><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> *</type>
          <declname>name</declname>
          <briefdescription><para>[in] A pointer to the name of the loop. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> *</type>
          <declname>var</declname>
          <briefdescription><para>[in] A pointer to the name of the variable to be updated by <emphasis>update</emphasis>. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_expr_node" kindref="compound">ExprNode</ref> *</type>
          <declname>guard</declname>
          <briefdescription><para>[in] A pointer to the expression to determine if the loop will continue. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_expr_node" kindref="compound">ExprNode</ref> *</type>
          <declname>update</declname>
          <briefdescription><para>[in] A pointer to the expression to evaluate to update <emphasis>var</emphasis>. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_block_node" kindref="compound">BlockNode</ref> *</type>
          <declname>body</declname>
          <briefdescription><para>[in] A pointer to the block of code to be executed with each iteration of the loop. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a <ref refid="struct_loop_stmt_node" kindref="compound">LoopStmtNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>name</emphasis> was created by createIdentifierNode(char *, const char *, unsigned int). </para><simplesectsep/><para><emphasis>var</emphasis> was created by createIdentifierNode(char *, const char *, unsigned int). </para><simplesectsep/><para><emphasis>guard</emphasis> was created by createExprNode(ExprType, void *). </para><simplesectsep/><para><emphasis>update</emphasis> was created by createExprNode(ExprType, void *). </para><simplesectsep/><para><emphasis>body</emphasis> was created by createBlockNode(StmtNodeList *).</para></simplesect>
<simplesect kind="return"><para>A pointer to a <ref refid="struct_loop_stmt_node" kindref="compound">LoopStmtNode</ref> structure with the desired properties.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deleteLoopStmtNode(LoopStmtNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="916" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="911" bodyend="928"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1aecacd84d092fc3a16b0c6ab32b440219" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void deleteLoopStmtNode</definition>
        <argsstring>(LoopStmtNode *node)</argsstring>
        <name>deleteLoopStmtNode</name>
        <param>
          <type><ref refid="struct_loop_stmt_node" kindref="compound">LoopStmtNode</ref> *</type>
          <declname>node</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_loop_stmt_node" kindref="compound">LoopStmtNode</ref> structure to be deleted. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Deletes a <ref refid="struct_loop_stmt_node" kindref="compound">LoopStmtNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>node</emphasis> was created by createLoopStmtNode(IdentifierNode *, IdentifierNode *, ExprNode *, ExprNode *, BlockNode *).</para></simplesect>
<simplesect kind="post"><para>The memory at <emphasis>node</emphasis> and any of its associated members will be freed.</para></simplesect>
<simplesect kind="see"><para>createLoopStmtNode(IdentifierNode *, IdentifierNode *, ExprNode *, ExprNode *, BlockNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="939" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="938" bodyend="947"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a7f73e98a023071061c207bc57dcd0dee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref> *</type>
        <definition>FuncDefStmtNode* createFuncDefStmtNode</definition>
        <argsstring>(IdentifierNode *scope, IdentifierNode *name, IdentifierNodeList *args, BlockNode *body)</argsstring>
        <name>createFuncDefStmtNode</name>
        <param>
          <type><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> *</type>
          <declname>scope</declname>
          <briefdescription><para>[in] A pointer to the scope to define the function in. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> *</type>
          <declname>name</declname>
          <briefdescription><para>[in] A pointer to the name of the function. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_identifier_node_list" kindref="compound">IdentifierNodeList</ref> *</type>
          <declname>args</declname>
          <briefdescription><para>[in] A pointer to an array of the names of the arguments of the function. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_block_node" kindref="compound">BlockNode</ref> *</type>
          <declname>body</declname>
          <briefdescription><para>[in] A pointer to the block of code defined by the function. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a <ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>scope</emphasis> was created by createIdentifierNode(char *, const char *, unsigned int). </para><simplesectsep/><para><emphasis>name</emphasis> was created by createIdentifierNode(char *, const char *, unsigned int). </para><simplesectsep/><para><emphasis>args</emphasis> was created by createIdentifierNodeList(void) and contains items added by addIdentifierNode(IdentifierNodeList *, IdentifierNode *). </para><simplesectsep/><para><emphasis>body</emphasis> was created by createBlockNode(StmtNodeList *).</para></simplesect>
<simplesect kind="return"><para>A pointer to a <ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref> structure with the desired properties.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deleteFuncDefStmtNode(FuncDefStmtNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="967" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="963" bodyend="978"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a337060b35ed8cf6f5c1e12e2e6d5e891" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void deleteFuncDefStmtNode</definition>
        <argsstring>(FuncDefStmtNode *node)</argsstring>
        <name>deleteFuncDefStmtNode</name>
        <param>
          <type><ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref> *</type>
          <declname>node</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref> structure to be deleted. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Deletes a <ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>node</emphasis> was created by createFuncDefStmtNode(IdentifierNode *, IdentifierNode *, IdentifierNodeList *, BlockNode *).</para></simplesect>
<simplesect kind="post"><para>The memory at <emphasis>node</emphasis> and any of its associated members will be freed.</para></simplesect>
<simplesect kind="see"><para>createFuncDefStmtNode(IdentifierNode *, IdentifierNode *, IdentifierNodeList *, BlockNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="989" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="988" bodyend="996"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1ab36f0b9e5b262b0dd97b0e46e96b24d5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_expr_node" kindref="compound">ExprNode</ref> *</type>
        <definition>ExprNode* createExprNode</definition>
        <argsstring>(ExprType type, void *expr)</argsstring>
        <name>createExprNode</name>
        <param>
          <type>ExprType</type>
          <declname>type</declname>
          <briefdescription><para>[in] The type of expression stored in <emphasis>expr</emphasis>. </para></briefdescription>
        </param>
        <param>
          <type>void *</type>
          <declname>expr</declname>
          <briefdescription><para>[in] A pointer to the particular expression structure. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates an <ref refid="struct_expr_node" kindref="compound">ExprNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>expr</emphasis> contains a structure created corresponding to <emphasis>type:</emphasis> <itemizedlist>
<listitem><para>ET_CAST: createCastExprNode(ExprNode *, TypeNode *)</para></listitem><listitem><para>ET_CONSTANT: createBooleanConstantNode(int), createIntegerConstantNode(int), createFloatConstantNode(float), or createStringConstantNode(char *).</para></listitem><listitem><para>ET_IDENTIFIER: createIdentifierNode(char *, const char *, unsigned int)</para></listitem><listitem><para>ET_FUNCCALL: createFuncCallExprNode(FuncDefStmtNode *, ExprNodeList *)</para></listitem><listitem><para>ET_OP: createOpExprNode(OpType, ExprNodeList *)</para></listitem><listitem><para>ET_IMPVAR: (for the <ref refid="impvar" kindref="compound">implicit variable</ref>) no structure needed, use <computeroutput>NULL</computeroutput> </para></listitem></itemizedlist>
</para></simplesect>
<simplesect kind="return"><para>A pointer to an <ref refid="struct_expr_node" kindref="compound">ExprNode</ref> structure with the desired properties.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deleteExprNode(ExprNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="1016" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="1014" bodyend="1025"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a1610e071c2e138a812b05fd85d608ead" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void deleteExprNode</definition>
        <argsstring>(ExprNode *node)</argsstring>
        <name>deleteExprNode</name>
        <param>
          <type><ref refid="struct_expr_node" kindref="compound">ExprNode</ref> *</type>
          <declname>node</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_expr_node" kindref="compound">ExprNode</ref> structure to be deleted. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Deletes an <ref refid="struct_expr_node" kindref="compound">ExprNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>node</emphasis> was created by createExprNode(ExprType, void *).</para></simplesect>
<simplesect kind="post"><para>The memory at <emphasis>node</emphasis> and any of its associated members will be freed.</para></simplesect>
<simplesect kind="see"><para>createExprNode(ExprType, void *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="1036" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="1035" bodyend="1061"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a976d79408740dce7ba2723415f9180b0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref> *</type>
        <definition>ExprNodeList* createExprNodeList</definition>
        <argsstring>(void)</argsstring>
        <name>createExprNodeList</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates an <ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref> structure.</para><para><simplesect kind="return"><para>A pointer to an <ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref> structure with the desired properties.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deleteExprNodeList(ExprNodeList *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="1071" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="1070" bodyend="1080"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a84e421c35a3317dd9f2985bd213904d8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_expr_node" kindref="compound">ExprNode</ref> *</type>
        <definition>ExprNode* addExprNode</definition>
        <argsstring>(ExprNodeList *list, ExprNode *node)</argsstring>
        <name>addExprNode</name>
        <param>
          <type><ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref> *</type>
          <declname>list</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref> structure to add <emphasis>node</emphasis> to. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_expr_node" kindref="compound">ExprNode</ref> *</type>
          <declname>node</declname>
          <briefdescription><para>[in] A pointer to the <ref refid="struct_expr_node" kindref="compound">ExprNode</ref> structure to add to <emphasis>list</emphasis>. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Adds an <ref refid="struct_expr_node" kindref="compound">ExprNode</ref> structure to an <ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>list</emphasis> was created by createExprNodeList(void). </para><simplesectsep/><para><emphasis>node</emphasis> was created by createExprNode(ExprType, void *).</para></simplesect>
<simplesect kind="post"><para><emphasis>node</emphasis> will be added on to the end of <emphasis>list</emphasis> and the size of <emphasis>list</emphasis> will be updated accordingly.</para></simplesect>
<simplesect kind="return"><para>A pointer to the added <ref refid="struct_expr_node" kindref="compound">ExprNode</ref> structure (will be the same as <emphasis>node</emphasis>).</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>realloc was unable to allocate memory. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="1096" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="1094" bodyend="1107"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a366d2606b5dc9e6b20fb1fd58621a27f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void deleteExprNodeList</definition>
        <argsstring>(ExprNodeList *list)</argsstring>
        <name>deleteExprNodeList</name>
        <param>
          <type><ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref> *</type>
          <declname>list</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref> structure to delete. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Deletes an <ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>list</emphasis> was created by createExprNodeList(void) and contains items added by addExprNode(ExprNodeList *, ExprNode *).</para></simplesect>
<simplesect kind="post"><para>The memory at <emphasis>list</emphasis> and any of its associated members will be freed.</para></simplesect>
<simplesect kind="see"><para>createExprNodeList(void) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="1119" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="1118" bodyend="1126"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a9fa09e58fee51a326a92cab995420cc7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_cast_expr_node" kindref="compound">CastExprNode</ref> *</type>
        <definition>CastExprNode* createCastExprNode</definition>
        <argsstring>(ExprNode *target, TypeNode *newtype)</argsstring>
        <name>createCastExprNode</name>
        <param>
          <type><ref refid="struct_expr_node" kindref="compound">ExprNode</ref> *</type>
          <declname>target</declname>
          <briefdescription><para>[in] A pointer to the expression to cast. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_type_node" kindref="compound">TypeNode</ref> *</type>
          <declname>newtype</declname>
          <briefdescription><para>[in] A pointer to the type to cast the copy of <emphasis>target</emphasis> to. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a <ref refid="struct_cast_expr_node" kindref="compound">CastExprNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>target</emphasis> was created by createExprNode(ExprType, void *). </para><simplesectsep/><para><emphasis>newtype</emphasis> was created by createTypeNode(ConstantType).</para></simplesect>
<simplesect kind="return"><para>A pointer to a <ref refid="struct_cast_expr_node" kindref="compound">CastExprNode</ref> structure with the desired properties.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deleteCastExprNode(CastExprNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="1140" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="1138" bodyend="1149"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1aa480c9bdc2b683a7060e20bb0a93e349" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void deleteCastExprNode</definition>
        <argsstring>(CastExprNode *node)</argsstring>
        <name>deleteCastExprNode</name>
        <param>
          <type><ref refid="struct_cast_expr_node" kindref="compound">CastExprNode</ref> *</type>
          <declname>node</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_cast_expr_node" kindref="compound">CastExprNode</ref> structure to be deleted. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Deletes a <ref refid="struct_cast_expr_node" kindref="compound">CastExprNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>node</emphasis> was created by createCastExprNode(ExprNode *, TypeNode *).</para></simplesect>
<simplesect kind="post"><para>The memory at <emphasis>node</emphasis> and any of its associated members will be freed.</para></simplesect>
<simplesect kind="see"><para>createCastExprNode(ExprNode *, TypeNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="1160" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="1159" bodyend="1165"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1abd8cad39ced5537d733a8cc5d64d3598" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_func_call_expr_node" kindref="compound">FuncCallExprNode</ref> *</type>
        <definition>FuncCallExprNode* createFuncCallExprNode</definition>
        <argsstring>(FuncDefStmtNode *def, ExprNodeList *args)</argsstring>
        <name>createFuncCallExprNode</name>
        <param>
          <type><ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref> *</type>
          <declname>def</declname>
          <briefdescription><para>[in] A pointer to the function definition to call. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref> *</type>
          <declname>args</declname>
          <briefdescription><para>[in] A pointer to an <ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref> structure of arguments to be supplied to the function defined by <emphasis>def</emphasis>. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a <ref refid="struct_func_call_expr_node" kindref="compound">FuncCallExprNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>def</emphasis> was created by createFuncDefStmtNode(IdentifierNode *, IdentifierNode *, IdentifierNodeList *, BlockNode *). </para><simplesectsep/><para><emphasis>args</emphasis> was created by createExprNodeList(void) and contains items added by addExprNode(ExprNodeList *, ExprNode *).</para></simplesect>
<simplesect kind="return"><para>A pointer to a <ref refid="struct_func_call_expr_node" kindref="compound">FuncCallExprNode</ref> structure with the desired properties.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deleteFuncCallExprNode(FuncCallExprNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="1181" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="1179" bodyend="1190"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1ab140ee4f88cdb5d30b7e6f03f7071edf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void deleteFuncCallExprNode</definition>
        <argsstring>(FuncCallExprNode *node)</argsstring>
        <name>deleteFuncCallExprNode</name>
        <param>
          <type><ref refid="struct_func_call_expr_node" kindref="compound">FuncCallExprNode</ref> *</type>
          <declname>node</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_func_call_expr_node" kindref="compound">FuncCallExprNode</ref> structure to be deleted. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Deletes a <ref refid="struct_func_call_expr_node" kindref="compound">FuncCallExprNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>node</emphasis> was created by createFuncCallExprNode(FuncDefStmtNode *, ExprNodeList *).</para></simplesect>
<simplesect kind="post"><para>The memory at <emphasis>node</emphasis> and any of its associated members will be freed.</para></simplesect>
<simplesect kind="see"><para>createFuncCallExprNode(FuncDefStmtNode *, ExprNodeList *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="1201" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="1200" bodyend="1205"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a250c5e71ecf3b4d096a12f37df2c3f01" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_op_expr_node" kindref="compound">OpExprNode</ref> *</type>
        <definition>OpExprNode* createOpExprNode</definition>
        <argsstring>(OpType type, ExprNodeList *args)</argsstring>
        <name>createOpExprNode</name>
        <param>
          <type>OpType</type>
          <declname>type</declname>
          <briefdescription><para>[in] The type of operation to perform on <emphasis>args</emphasis>. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref> *</type>
          <declname>args</declname>
          <briefdescription><para>[in] A pointer to the arguments to perform the operation on. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates an <ref refid="struct_op_expr_node" kindref="compound">OpExprNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>args</emphasis> was created by createExprNodeList(void) and contains items added by addExprNode(ExprNodeList *, ExprNode *).</para></simplesect>
<simplesect kind="return"><para>A pointer to an <ref refid="struct_op_expr_node" kindref="compound">OpExprNode</ref> structure with the desired properties.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deleteOpExprNode(OpExprNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="1219" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="1217" bodyend="1228"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a0400c388330a025fb9f71e8bb8dfc752" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void deleteOpExprNode</definition>
        <argsstring>(OpExprNode *node)</argsstring>
        <name>deleteOpExprNode</name>
        <param>
          <type><ref refid="struct_op_expr_node" kindref="compound">OpExprNode</ref> *</type>
          <declname>node</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_op_expr_node" kindref="compound">OpExprNode</ref> structure to be deleted. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Deletes an <ref refid="struct_op_expr_node" kindref="compound">OpExprNode</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>node</emphasis> was created by createOpExprNode(OpType, ExprNodeList *).</para></simplesect>
<simplesect kind="post"><para>The memory at <emphasis>node</emphasis> and any of its associated members will be freed.</para></simplesect>
<simplesect kind="see"><para>createOpExprNode(OpType, ExprNodeList *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="1239" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="1238" bodyend="1243"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a9c514111216208f96820a3362fa12baa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_function_table" kindref="compound">FunctionTable</ref> *</type>
        <definition>FunctionTable* createFunctionTable</definition>
        <argsstring>(void)</argsstring>
        <name>createFunctionTable</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a <ref refid="struct_function_table" kindref="compound">FunctionTable</ref> structure.</para><para><simplesect kind="return"><para>A pointer to a <ref refid="struct_function_table" kindref="compound">FunctionTable</ref> structure with no elements.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>malloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>deleteFunctionTable(FunctionTable *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="1253" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="1252" bodyend="1262"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1afeb67556a0e6325ae841d49980460200" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref> *</type>
        <definition>FuncDefStmtNode* addFuncDefStmtNode</definition>
        <argsstring>(FunctionTable *table, FuncDefStmtNode *node)</argsstring>
        <name>addFuncDefStmtNode</name>
        <param>
          <type><ref refid="struct_function_table" kindref="compound">FunctionTable</ref> *</type>
          <declname>table</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_function_table" kindref="compound">FunctionTable</ref> structure to add <emphasis>node</emphasis> to. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref> *</type>
          <declname>node</declname>
          <briefdescription><para>[in] A pointer to the <ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref> structure to add to <emphasis>table</emphasis>. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Adds a <ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref> to a <ref refid="struct_function_table" kindref="compound">FunctionTable</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>table</emphasis> was created by createFunctionTable(void). </para><simplesectsep/><para><emphasis>node</emphasis> was created by createFuncDefStmtNode(IdentifierNode *, IdentifierNode *, IdentifierNodeList *, BlockNode *).</para></simplesect>
<simplesect kind="post"><para><emphasis>node</emphasis> will be added on to the end of <emphasis>table</emphasis> and the size of <emphasis>table</emphasis> will be updated accordingly.</para></simplesect>
<simplesect kind="return"><para>A pointer to the added <ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref> structure (will be the same as <emphasis>node</emphasis>).</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>realloc was unable to allocate memory.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>lookupFuncDefStmtNode(FunctionTable *, const char *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="1280" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="1278" bodyend="1291"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1aa05c7937852b5e395d2f4dfc557c02b7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void deleteFunctionTable</definition>
        <argsstring>(FunctionTable *table)</argsstring>
        <name>deleteFunctionTable</name>
        <param>
          <type><ref refid="struct_function_table" kindref="compound">FunctionTable</ref> *</type>
          <declname>table</declname>
          <briefdescription><para>[in,out] A pointer to the <ref refid="struct_function_table" kindref="compound">FunctionTable</ref> structure to delete. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Deletes a <ref refid="struct_function_table" kindref="compound">FunctionTable</ref> structure.</para><para><simplesect kind="pre"><para><emphasis>table</emphasis> was created by createFunctionTable(void).</para></simplesect>
<simplesect kind="post"><para>The memory of the function table and any of its associated members will be freed.</para></simplesect>
<simplesect kind="see"><para>createFunctionTable(void) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="1302" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="1301" bodyend="1308"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a424077fa31c9eba6acea24c820715202" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref> *</type>
        <definition>FuncDefStmtNode* lookupFuncDefStmtNode</definition>
        <argsstring>(FunctionTable *table, const char *name)</argsstring>
        <name>lookupFuncDefStmtNode</name>
        <param>
          <type><ref refid="struct_function_table" kindref="compound">FunctionTable</ref> *</type>
          <declname>table</declname>
          <briefdescription><para>[in] A pointer to the <ref refid="struct_function_table" kindref="compound">FunctionTable</ref> structure to search for <emphasis>name</emphasis>. </para></briefdescription>
        </param>
        <param>
          <type>const char *</type>
          <declname>name</declname>
          <briefdescription><para>[in] The name of the function to look up. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Looks up a function definition by its name.</para><para><simplesect kind="pre"><para><emphasis>table</emphasis> was created by createFunctionTable(void) and contains items added by addFuncDefStmtNode(FunctionTable *, FuncDefStmtNode *).</para></simplesect>
<simplesect kind="return"><para>A pointer to the <ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref> structure named <emphasis>name</emphasis>.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>No such <ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref> structure exists.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>addFuncDefStmtNode(FunctionTable *, FuncDefStmtNode *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="1322" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="1320" bodyend="1329"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1ad42d9df31ba34d692cc89cc0406a09a5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int acceptToken</definition>
        <argsstring>(Token ***tokenp, TokenType token)</argsstring>
        <name>acceptToken</name>
        <param>
          <type><ref refid="struct_token" kindref="compound">Token</ref> ***</type>
          <declname>tokenp</declname>
          <briefdescription><para>[in,out] A pointer to the position of the next token to parse in an array of <ref refid="struct_token" kindref="compound">Token</ref> structures. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="tokenizer_8h_1aa520fbf142ba1e7e659590c07da31921" kindref="member">TokenType</ref></type>
          <declname>token</declname>
          <briefdescription><para>[in] The type of token to match. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Checks if the token pointed to by <emphasis>tokenp</emphasis> matches <emphasis>token</emphasis> and if it does, advances the token pointer to the next token in the array.</para><para><simplesect kind="note"><para>Unlike peekToken(Token ***, TokenType) and nextToken(Token ***, TokenType), this function <bold>does</bold> modify <emphasis>tokenp</emphasis>.</para></simplesect>
<simplesect kind="pre"><para><emphasis>tokenp</emphasis> points to a position in an array of tokens created by tokenizeLexemes(Lexeme **).</para></simplesect>
<simplesect kind="post"><para>If the token pointed to by <emphasis>tokenp</emphasis> does not match <emphasis>token</emphasis>, <emphasis>tokenp</emphasis> will point to the same token as when the function was called. </para><simplesectsep/><para>If the token pointed to by <emphasis>tokenp</emphasis> matches <emphasis>token</emphasis>, <emphasis>tokenp</emphasis> will point to the next token <bold>after</bold> the one matched.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>The token does not match <emphasis>token</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>1</parametername>
</parameternamelist>
<parameterdescription>
<para>The token matches <emphasis>token</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>peekToken(Token ***, TokenType) </para><simplesectsep/><para>nextToken(Token ***, TokenType) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="1353" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="1351" bodyend="1359"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1af9957220bd0480dcfa551246ba16d0d8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int peekToken</definition>
        <argsstring>(Token ***tokenp, TokenType token)</argsstring>
        <name>peekToken</name>
        <param>
          <type><ref refid="struct_token" kindref="compound">Token</ref> ***</type>
          <declname>tokenp</declname>
          <briefdescription><para>[in] A pointer to the position of the next token to parse in an array of <ref refid="struct_token" kindref="compound">Token</ref> structures. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="tokenizer_8h_1aa520fbf142ba1e7e659590c07da31921" kindref="member">TokenType</ref></type>
          <declname>token</declname>
          <briefdescription><para>[in] The type of token to match. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Checks if the token pointed to by <emphasis>tokenp</emphasis> matches <emphasis>token</emphasis>.</para><para><simplesect kind="note"><para>Unlike acceptToken(Token ***, TokenType), this function does not modify <emphasis>tokenp</emphasis>.</para></simplesect>
<simplesect kind="pre"><para><emphasis>tokenp</emphasis> points to a position in an array of tokens created by tokenizeLexemes(Lexeme **).</para></simplesect>
<simplesect kind="post"><para><emphasis>tokenp</emphasis> will point to the same token as when the function was called.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>The token does not match <emphasis>token</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>1</parametername>
</parameternamelist>
<parameterdescription>
<para>The token matches <emphasis>token</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>acceptToken(Token ***, TokenType) </para><simplesectsep/><para>nextToken(Token ***, TokenType) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="1379" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="1377" bodyend="1383"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1aa10261047594f44b492647cfdf6f6f3d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int nextToken</definition>
        <argsstring>(Token ***tokenp, TokenType token)</argsstring>
        <name>nextToken</name>
        <param>
          <type><ref refid="struct_token" kindref="compound">Token</ref> ***</type>
          <declname>tokenp</declname>
          <briefdescription><para>[in] A pointer to the position of the next token to parse in an array of <ref refid="struct_token" kindref="compound">Token</ref> structures. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="tokenizer_8h_1aa520fbf142ba1e7e659590c07da31921" kindref="member">TokenType</ref></type>
          <declname>token</declname>
          <briefdescription><para>[in] The type of token to match. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Checks if the token <bold>after</bold> the one pointed to by <emphasis>tokenp</emphasis> matches <emphasis>token</emphasis>.</para><para><simplesect kind="note"><para>Unlike acceptToken(Token ***, TokenType), this function does not modify <emphasis>tokenp</emphasis>.</para></simplesect>
<simplesect kind="pre"><para><emphasis>tokenp</emphasis> points to a position in an array of tokens created by tokenizeLexemes(Lexeme **).</para></simplesect>
<simplesect kind="post"><para><emphasis>tokenp</emphasis> will point to the same token as when the function was called.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>The next token does not match <emphasis>token</emphasis>. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>1</parametername>
</parameternamelist>
<parameterdescription>
<para>The next token matches <emphasis>token</emphasis>.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>acceptToken(Token ***, TokenType) </para><simplesectsep/><para>peekToken(Token ***, TokenType) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="1404" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="1402" bodyend="1408"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a63862190f7197d10ec75fdf5cd4ce1ce" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void error</definition>
        <argsstring>(const char *info, Token **tokens)</argsstring>
        <name>error</name>
        <param>
          <type>const char *</type>
          <declname>info</declname>
          <briefdescription><para>[in] The array of characters to print. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_token" kindref="compound">Token</ref> **</type>
          <declname>tokens</declname>
          <briefdescription><para>[in] A pointer to an array of tokens to parse. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Prints an error message of the form &quot;LINE: INFO before: NEXT.\n&quot;, where LINE is the line the next token appears on, INFO is <emphasis>info</emphasis> and NEXT is the image of the next token.</para><para><simplesect kind="pre"><para><emphasis>tokens</emphasis> was created by tokenizeLexemes(Lexeme **). </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="1417" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="1415" bodyend="1419"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a493791945f27cac200999fadcadd3276" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_constant_node" kindref="compound">ConstantNode</ref> *</type>
        <definition>ConstantNode* parseConstantNode</definition>
        <argsstring>(Token ***tokenp)</argsstring>
        <name>parseConstantNode</name>
        <param>
          <type><ref refid="struct_token" kindref="compound">Token</ref> ***</type>
          <declname>tokenp</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Parses a set of tokens into a <ref refid="struct_constant_node" kindref="compound">ConstantNode</ref> structure. Parsing begins at the token pointed to by <emphasis>tokenp</emphasis>.</para><para><simplesect kind="pre"><para><emphasis>tokenp</emphasis> points to a position in an array of tokens created by tokenizeLexemes(Lexeme **).</para></simplesect>
<simplesect kind="post"><para><emphasis>tokenp</emphasis> will point to the next <bold>unparsed</bold> token in the array.</para></simplesect>
<simplesect kind="return"><para>A pointer to the generated <ref refid="struct_constant_node" kindref="compound">ConstantNode</ref> structure.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>An error occurred during parsing.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>parseTypeNode(Token ***) </para><simplesectsep/><para>parseIdentifierNode(Token ***) </para><simplesectsep/><para>parseExprNode(Token ***, FunctionTable *) </para><simplesectsep/><para>parseStmtNode(Token ***, FunctionTable *) </para><simplesectsep/><para>parseBlockNode(Token ***, FunctionTable *) </para><simplesectsep/><para>parseMainNode(Token **, FunctionTable *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="1440" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="1439" bodyend="1499"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a77b4f6cbfced83754ac9547742f14d94" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_type_node" kindref="compound">TypeNode</ref> *</type>
        <definition>TypeNode* parseTypeNode</definition>
        <argsstring>(Token ***tokenp)</argsstring>
        <name>parseTypeNode</name>
        <param>
          <type><ref refid="struct_token" kindref="compound">Token</ref> ***</type>
          <declname>tokenp</declname>
          <briefdescription><para>[in,out] A pointer to the position of the next token to parse. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Parses a set of tokens into a <ref refid="struct_type_node" kindref="compound">TypeNode</ref> structure. Parsing begins at the token pointed to by <emphasis>tokenp</emphasis>.</para><para><simplesect kind="pre"><para><emphasis>tokenp</emphasis> points to a position in an array of tokens created by tokenizeLexemes(Lexeme **).</para></simplesect>
<simplesect kind="post"><para><emphasis>tokenp</emphasis> will point to the next <bold>unparsed</bold> token in the array.</para></simplesect>
<simplesect kind="return"><para>A pointer to the generated <ref refid="struct_expr_node" kindref="compound">ExprNode</ref> structure.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>An error occurred during parsing.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>parseConstantNode(Token ***) </para><simplesectsep/><para>parseIdentifierNode(Token ***) </para><simplesectsep/><para>parseExprNode(Token ***, FunctionTable *) </para><simplesectsep/><para>parseStmtNode(Token ***, FunctionTable *) </para><simplesectsep/><para>parseBlockNode(Token ***, FunctionTable *) </para><simplesectsep/><para>parseMainNode(Token **, FunctionTable *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="1520" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="1519" bodyend="1572"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1aad0f490bc610eef7c5cf371095882156" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> *</type>
        <definition>IdentifierNode* parseIdentifierNode</definition>
        <argsstring>(Token ***tokenp)</argsstring>
        <name>parseIdentifierNode</name>
        <param>
          <type><ref refid="struct_token" kindref="compound">Token</ref> ***</type>
          <declname>tokenp</declname>
          <briefdescription><para>[in,out] A pointer to the position of the next token to parse. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Parses a set of tokens into an <ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> structure. Parsing begins at the token pointed to by <emphasis>tokenp</emphasis>.</para><para><simplesect kind="pre"><para><emphasis>tokenp</emphasis> points to a position in an array of tokens created by tokenizeLexemes(Lexeme **).</para></simplesect>
<simplesect kind="post"><para><emphasis>tokenp</emphasis> will point to the next <bold>unparsed</bold> token in the array.</para></simplesect>
<simplesect kind="return"><para>A pointer to the generated <ref refid="struct_expr_node" kindref="compound">ExprNode</ref> structure.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>An error occurred during parsing.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>parseConstantNode(Token ***) </para><simplesectsep/><para>parseTypeNode(Token ***) </para><simplesectsep/><para>parseExprNode(Token ***, FunctionTable *) </para><simplesectsep/><para>parseStmtNode(Token ***, FunctionTable *) </para><simplesectsep/><para>parseBlockNode(Token ***, FunctionTable *) </para><simplesectsep/><para>parseMainNode(Token **, FunctionTable *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="1593" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="1592" bodyend="1613"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a35eb2965deca64171872f081247fc54d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_expr_node" kindref="compound">ExprNode</ref> *</type>
        <definition>ExprNode* parseExprNode</definition>
        <argsstring>(Token ***tokenp, FunctionTable *functab)</argsstring>
        <name>parseExprNode</name>
        <param>
          <type><ref refid="struct_token" kindref="compound">Token</ref> ***</type>
          <declname>tokenp</declname>
          <briefdescription><para>[in,out] A pointer to the position of the next token to parse. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_function_table" kindref="compound">FunctionTable</ref> *</type>
          <declname>functab</declname>
          <briefdescription><para>[in,out] A pointer to the table of defined functions. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Parses a set of tokens into an <ref refid="struct_expr_node" kindref="compound">ExprNode</ref> structure. Parsing begins at the token pointed to by <emphasis>tokenp</emphasis>.</para><para><simplesect kind="pre"><para><emphasis>tokenp</emphasis> points to a position in an array of tokens created by tokenizeLexemes(Lexeme **).</para></simplesect>
<simplesect kind="post"><para><emphasis>tokenp</emphasis> will point to the next <bold>unparsed</bold> token in the array.</para></simplesect>
<simplesect kind="return"><para>A pointer to the generated <ref refid="struct_expr_node" kindref="compound">ExprNode</ref> structure.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>An error occurred during parsing.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>parseConstantNode(Token ***) </para><simplesectsep/><para>parseTypeNode(Token ***) </para><simplesectsep/><para>parseIdentifierNode(Token ***) </para><simplesectsep/><para>parseStmtNode(Token ***, FunctionTable *) </para><simplesectsep/><para>parseBlockNode(Token ***, FunctionTable *) </para><simplesectsep/><para>parseMainNode(Token **, FunctionTable *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="1635" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="1633" bodyend="1983"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a878b7bacc96ab8b25932c909a198c227" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_stmt_node" kindref="compound">StmtNode</ref> *</type>
        <definition>StmtNode* parseStmtNode</definition>
        <argsstring>(Token ***tokenp, FunctionTable *functab)</argsstring>
        <name>parseStmtNode</name>
        <param>
          <type><ref refid="struct_token" kindref="compound">Token</ref> ***</type>
          <declname>tokenp</declname>
          <briefdescription><para>[in,out] A pointer to the position of the next token to parse. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_function_table" kindref="compound">FunctionTable</ref> *</type>
          <declname>functab</declname>
          <briefdescription><para>[in,out] A pointer to the table of defined functions. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Parses a set of tokens into a <ref refid="struct_stmt_node" kindref="compound">StmtNode</ref> structure. Parsing begins at the token pointed to by <emphasis>tokenp</emphasis>.</para><para><simplesect kind="pre"><para><emphasis>tokenp</emphasis> points to a position in an array of tokens created by tokenizeLexemes(Lexeme **).</para></simplesect>
<simplesect kind="post"><para><emphasis>tokenp</emphasis> will point to the next <bold>unparsed</bold> token in the array.</para></simplesect>
<simplesect kind="return"><para>A pointer to the generated <ref refid="struct_stmt_node" kindref="compound">StmtNode</ref> structure.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>An error occurred during parsing.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>parseConstantNode(Token ***) </para><simplesectsep/><para>parseTypeNode(Token ***) </para><simplesectsep/><para>parseIdentifierNode(Token ***) </para><simplesectsep/><para>parseExprNode(Token ***, FunctionTable *) </para><simplesectsep/><para>parseBlockNode(Token ***, FunctionTable *) </para><simplesectsep/><para>parseMainNode(Token **, FunctionTable *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
<para><simplesect kind="note"><para>The 1.2 specification only allows constant values for OMG guards thus this function explicitly checks for them. </para></simplesect>
</para>        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="2005" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="2003" bodyend="2872"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a75b8f98659608e09cdb597164f1ad1e0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_block_node" kindref="compound">BlockNode</ref> *</type>
        <definition>BlockNode* parseBlockNode</definition>
        <argsstring>(Token ***tokenp, FunctionTable *functab)</argsstring>
        <name>parseBlockNode</name>
        <param>
          <type><ref refid="struct_token" kindref="compound">Token</ref> ***</type>
          <declname>tokenp</declname>
          <briefdescription><para>[in,out] A pointer to the position of the next token to parse. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_function_table" kindref="compound">FunctionTable</ref> *</type>
          <declname>functab</declname>
          <briefdescription><para>[in,out] A pointer to the table of defined functions. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Parses a set of tokens into a <ref refid="struct_block_node" kindref="compound">BlockNode</ref> structure. Parsing begins at the token pointed to by <emphasis>tokenp</emphasis>.</para><para><simplesect kind="pre"><para><emphasis>tokenp</emphasis> points to a position in an array of tokens created by tokenizeLexemes(Lexeme **).</para></simplesect>
<simplesect kind="post"><para><emphasis>tokenp</emphasis> will point to the next <bold>unparsed</bold> token in the array.</para></simplesect>
<simplesect kind="return"><para>A pointer to the generated <ref refid="struct_block_node" kindref="compound">BlockNode</ref> structure.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>An error occurred during parsing.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>parseConstantNode(Token ***) </para><simplesectsep/><para>parseTypeNode(Token ***) </para><simplesectsep/><para>parseIdentifierNode(Token ***) </para><simplesectsep/><para>parseExprNode(Token ***, FunctionTable *) </para><simplesectsep/><para>parseStmtNode(Token ***, FunctionTable *) </para><simplesectsep/><para>parseMainNode(Token **, FunctionTable *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="2894" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="2892" bodyend="2928"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a51409af282c1282c87060dd526047af0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_main_node" kindref="compound">MainNode</ref> *</type>
        <definition>MainNode* parseMainNode</definition>
        <argsstring>(Token **tokens, FunctionTable *functab)</argsstring>
        <name>parseMainNode</name>
        <param>
          <type><ref refid="struct_token" kindref="compound">Token</ref> **</type>
          <declname>tokens</declname>
          <briefdescription><para>[in] A pointer to an array of tokens to parse. </para></briefdescription>
        </param>
        <param>
          <type><ref refid="struct_function_table" kindref="compound">FunctionTable</ref> *</type>
          <declname>functab</declname>
          <briefdescription><para>[in,out] A pointer to a table of function prototypes. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Parses <emphasis>tokens</emphasis> into a <ref refid="struct_main_node" kindref="compound">MainNode</ref> structure, an intermediary form to be passed along to a later stage of processing such as, for example, an interpreter.</para><para><simplesect kind="pre"><para><emphasis>tokens</emphasis> was created by tokenizeLexemes(Lexeme **). </para><simplesectsep/><para><emphasis>functab</emphasis> was created by setupFunctionTable(Token **).</para></simplesect>
<simplesect kind="return"><para>A pointer to the generated <ref refid="struct_main_node" kindref="compound">MainNode</ref> structure.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>An error occurred during parsing.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para>parseConstantNode(Token ***) </para><simplesectsep/><para>parseTypeNode(Token ***) </para><simplesectsep/><para>parseIdentifierNode(Token ***) </para><simplesectsep/><para>parseExprNode(Token ***, FunctionTable *) </para><simplesectsep/><para>parseStmtNode(Token ***, FunctionTable *) </para><simplesectsep/><para>parseBlockNode(Token ***, FunctionTable *) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="2949" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="2947" bodyend="2979"/>
      </memberdef>
      <memberdef kind="function" id="parser_8c_1a99408b756d5aae00b72b5129f79e649b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="struct_function_table" kindref="compound">FunctionTable</ref> *</type>
        <definition>FunctionTable* setupFunctionTable</definition>
        <argsstring>(Token **tokens)</argsstring>
        <name>setupFunctionTable</name>
        <param>
          <type><ref refid="struct_token" kindref="compound">Token</ref> **</type>
          <declname>tokens</declname>
          <briefdescription><para>[in] A pointer to an array of tokens to scan for function prototypes. </para></briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Sets up a <ref refid="struct_function_table" kindref="compound">FunctionTable</ref> structure filled with the prototypes of all declared functions. This structure is then passed as an argument to parseMainNode(Token **, FunctionTable *) so that functions may be called before their definition as well as recursively.</para><para><simplesect kind="pre"><para><emphasis>tokens</emphasis> was created by tokenizeLexemes(Lexeme **).</para></simplesect>
<simplesect kind="return"><para>A pointer to the generated <ref refid="struct_function_table" kindref="compound">FunctionTable</ref> structure.</para></simplesect>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>NULL</parametername>
</parameternamelist>
<parameterdescription>
<para>An error occurred during setup. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" line="2991" bodyfile="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c" bodystart="2990" bodyend="3076"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="preprocessor">#include<sp/>&quot;parser.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2"><highlight class="normal"></highlight></codeline>
<codeline lineno="3"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="4"><highlight class="preprocessor"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>shiftwidth<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="5"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>shiftout(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">)<sp/>{<sp/>shiftwidth<sp/>+=<sp/>4;<sp/>}</highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>shiftin(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">)<sp/>{<sp/>shiftwidth<sp/>-=<sp/>4;<sp/>}</highlight></codeline>
<codeline lineno="7"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>debug(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*info)</highlight></codeline>
<codeline lineno="8"><highlight class="normal">{</highlight></codeline>
<codeline lineno="9"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n;</highlight></codeline>
<codeline lineno="10"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(n<sp/>=<sp/>0;<sp/>n<sp/>&lt;<sp/>shiftwidth;<sp/>n++)</highlight></codeline>
<codeline lineno="11"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/></highlight><highlight class="stringliteral">&quot;<sp/>&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="12"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/></highlight><highlight class="stringliteral">&quot;%s\n&quot;</highlight><highlight class="normal">,<sp/>info);</highlight></codeline>
<codeline lineno="13"><highlight class="normal">}</highlight></codeline>
<codeline lineno="14"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="15"><highlight class="preprocessor"></highlight></codeline>
<codeline lineno="27"><highlight class="normal"><ref refid="struct_main_node" kindref="compound">MainNode</ref><sp/>*createMainNode(<ref refid="struct_block_node" kindref="compound">BlockNode</ref><sp/>*block,<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="28"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_function_table" kindref="compound">FunctionTable</ref><sp/>*functab)<sp/></highlight></codeline>
<codeline lineno="29"><highlight class="normal">{</highlight></codeline>
<codeline lineno="30"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_main_node" kindref="compound">MainNode</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_main_node" kindref="compound">MainNode</ref>));</highlight></codeline>
<codeline lineno="31"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="32"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="33"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="34"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="35"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_main_node_1aee302d107abb16c48702c2699a58d49f" kindref="member">block</ref><sp/>=<sp/>block;</highlight></codeline>
<codeline lineno="36"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_main_node_1a1b22e4833219bb71c9ca7f32d3e37241" kindref="member">functab</ref><sp/>=<sp/>functab;</highlight></codeline>
<codeline lineno="37"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="38"><highlight class="normal">}</highlight></codeline>
<codeline lineno="39"><highlight class="normal"></highlight></codeline>
<codeline lineno="48"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>deleteMainNode(<ref refid="struct_main_node" kindref="compound">MainNode</ref><sp/>*node)<sp/></highlight></codeline>
<codeline lineno="49"><highlight class="normal">{</highlight></codeline>
<codeline lineno="50"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!node)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="51"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(node-&gt;<ref refid="struct_main_node_1aee302d107abb16c48702c2699a58d49f" kindref="member">block</ref>);</highlight></codeline>
<codeline lineno="52"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteFunctionTable(node-&gt;<ref refid="struct_main_node_1a1b22e4833219bb71c9ca7f32d3e37241" kindref="member">functab</ref>);</highlight></codeline>
<codeline lineno="53"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(node);</highlight></codeline>
<codeline lineno="54"><highlight class="normal">}</highlight></codeline>
<codeline lineno="55"><highlight class="normal"></highlight></codeline>
<codeline lineno="66"><highlight class="normal"><ref refid="struct_block_node" kindref="compound">BlockNode</ref><sp/>*createBlockNode(<ref refid="struct_stmt_node_list" kindref="compound">StmtNodeList</ref><sp/>*stmts)<sp/></highlight></codeline>
<codeline lineno="67"><highlight class="normal">{</highlight></codeline>
<codeline lineno="68"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_block_node" kindref="compound">BlockNode</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_block_node" kindref="compound">BlockNode</ref>));</highlight></codeline>
<codeline lineno="69"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="70"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="71"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="72"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="73"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_block_node_1a5d918092ee6d41f6be62dff435aede89" kindref="member">stmts</ref><sp/>=<sp/>stmts;</highlight></codeline>
<codeline lineno="74"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="75"><highlight class="normal">}</highlight></codeline>
<codeline lineno="76"><highlight class="normal"></highlight></codeline>
<codeline lineno="85"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>deleteBlockNode(<ref refid="struct_block_node" kindref="compound">BlockNode</ref><sp/>*node)<sp/></highlight></codeline>
<codeline lineno="86"><highlight class="normal">{</highlight></codeline>
<codeline lineno="87"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!node)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="88"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteStmtNodeList(node-&gt;<ref refid="struct_block_node_1a5d918092ee6d41f6be62dff435aede89" kindref="member">stmts</ref>);</highlight></codeline>
<codeline lineno="89"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(node);</highlight></codeline>
<codeline lineno="90"><highlight class="normal">}</highlight></codeline>
<codeline lineno="91"><highlight class="normal"></highlight></codeline>
<codeline lineno="99"><highlight class="normal"><ref refid="struct_block_node_list" kindref="compound">BlockNodeList</ref><sp/>*createBlockNodeList(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="100"><highlight class="normal">{</highlight></codeline>
<codeline lineno="101"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_block_node_list" kindref="compound">BlockNodeList</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_block_node_list" kindref="compound">BlockNodeList</ref>));</highlight></codeline>
<codeline lineno="102"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="105"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="106"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_block_node_list_1af36c77e76b73f0fa500ada63aaad2dd7" kindref="member">num</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="107"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_block_node_list_1a97ab8b891f65c2f8152712d59f69be64" kindref="member">blocks</ref><sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="108"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="109"><highlight class="normal">}</highlight></codeline>
<codeline lineno="110"><highlight class="normal"></highlight></codeline>
<codeline lineno="122"><highlight class="normal"><ref refid="struct_block_node" kindref="compound">BlockNode</ref><sp/>*addBlockNode(<ref refid="struct_block_node_list" kindref="compound">BlockNodeList</ref><sp/>*list,<sp/><sp/></highlight></codeline>
<codeline lineno="123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_block_node" kindref="compound">BlockNode</ref><sp/>*node)<sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="124"><highlight class="normal">{</highlight></codeline>
<codeline lineno="125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>newsize<sp/>=<sp/>list-&gt;<ref refid="struct_block_node_list_1af36c77e76b73f0fa500ada63aaad2dd7" kindref="member">num</ref><sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*mem<sp/>=<sp/>realloc(list-&gt;<ref refid="struct_block_node_list_1a97ab8b891f65c2f8152712d59f69be64" kindref="member">blocks</ref>,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_block_node" kindref="compound">BlockNode</ref><sp/>*)<sp/>*<sp/>newsize);</highlight></codeline>
<codeline lineno="127"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!mem)<sp/>{</highlight></codeline>
<codeline lineno="128"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;realloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="129"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>list-&gt;<ref refid="struct_block_node_list_1a97ab8b891f65c2f8152712d59f69be64" kindref="member">blocks</ref><sp/>=<sp/>mem;</highlight></codeline>
<codeline lineno="132"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>list-&gt;<ref refid="struct_block_node_list_1a97ab8b891f65c2f8152712d59f69be64" kindref="member">blocks</ref>[list-&gt;<ref refid="struct_block_node_list_1af36c77e76b73f0fa500ada63aaad2dd7" kindref="member">num</ref>]<sp/>=<sp/>node;</highlight></codeline>
<codeline lineno="133"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>list-&gt;<ref refid="struct_block_node_list_1af36c77e76b73f0fa500ada63aaad2dd7" kindref="member">num</ref><sp/>=<sp/>newsize;</highlight></codeline>
<codeline lineno="134"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>node;</highlight></codeline>
<codeline lineno="135"><highlight class="normal">}</highlight></codeline>
<codeline lineno="136"><highlight class="normal"></highlight></codeline>
<codeline lineno="146"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>deleteBlockNodeList(<ref refid="struct_block_node_list" kindref="compound">BlockNodeList</ref><sp/>*list)<sp/></highlight></codeline>
<codeline lineno="147"><highlight class="normal">{</highlight></codeline>
<codeline lineno="148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n;</highlight></codeline>
<codeline lineno="149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!list)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="150"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(n<sp/>=<sp/>0;<sp/>n<sp/>&lt;<sp/>list-&gt;<ref refid="struct_block_node_list_1af36c77e76b73f0fa500ada63aaad2dd7" kindref="member">num</ref>;<sp/>n++)</highlight></codeline>
<codeline lineno="151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(list-&gt;<ref refid="struct_block_node_list_1a97ab8b891f65c2f8152712d59f69be64" kindref="member">blocks</ref>[n]);</highlight></codeline>
<codeline lineno="152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(list-&gt;<ref refid="struct_block_node_list_1a97ab8b891f65c2f8152712d59f69be64" kindref="member">blocks</ref>);</highlight></codeline>
<codeline lineno="153"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(list);</highlight></codeline>
<codeline lineno="154"><highlight class="normal">}</highlight></codeline>
<codeline lineno="155"><highlight class="normal"></highlight></codeline>
<codeline lineno="164"><highlight class="normal"><ref refid="struct_constant_node" kindref="compound">ConstantNode</ref><sp/>*createBooleanConstantNode(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>data)<sp/></highlight></codeline>
<codeline lineno="165"><highlight class="normal">{</highlight></codeline>
<codeline lineno="166"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_constant_node" kindref="compound">ConstantNode</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_constant_node" kindref="compound">ConstantNode</ref>));</highlight></codeline>
<codeline lineno="167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="168"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="170"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="171"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_constant_node_1ae0c5b58398f2ff9a476628ea34858893" kindref="member">type</ref><sp/>=<sp/>CT_BOOLEAN;</highlight></codeline>
<codeline lineno="172"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_constant_node_1ae546bb49962906e06a965381014ea7ae" kindref="member">data</ref>.<ref refid="union_constant_data_1a2bd6e6fb99485a02c81794d2a3fc5a41" kindref="member">i</ref><sp/>=<sp/>(data<sp/>!=<sp/>0);</highlight></codeline>
<codeline lineno="173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="174"><highlight class="normal">}</highlight></codeline>
<codeline lineno="175"><highlight class="normal"></highlight></codeline>
<codeline lineno="183"><highlight class="normal"><ref refid="struct_constant_node" kindref="compound">ConstantNode</ref><sp/>*createIntegerConstantNode(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>data)<sp/></highlight></codeline>
<codeline lineno="184"><highlight class="normal">{</highlight></codeline>
<codeline lineno="185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_constant_node" kindref="compound">ConstantNode</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_constant_node" kindref="compound">ConstantNode</ref>));</highlight></codeline>
<codeline lineno="186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="187"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="188"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="189"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="190"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_constant_node_1ae0c5b58398f2ff9a476628ea34858893" kindref="member">type</ref><sp/>=<sp/>CT_INTEGER;</highlight></codeline>
<codeline lineno="191"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_constant_node_1ae546bb49962906e06a965381014ea7ae" kindref="member">data</ref>.<ref refid="union_constant_data_1a2bd6e6fb99485a02c81794d2a3fc5a41" kindref="member">i</ref><sp/>=<sp/>data;</highlight></codeline>
<codeline lineno="192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="193"><highlight class="normal">}</highlight></codeline>
<codeline lineno="194"><highlight class="normal"></highlight></codeline>
<codeline lineno="203"><highlight class="normal"><ref refid="struct_constant_node" kindref="compound">ConstantNode</ref><sp/>*createFloatConstantNode(</highlight><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>data)<sp/></highlight></codeline>
<codeline lineno="204"><highlight class="normal">{</highlight></codeline>
<codeline lineno="205"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_constant_node" kindref="compound">ConstantNode</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_constant_node" kindref="compound">ConstantNode</ref>));</highlight></codeline>
<codeline lineno="206"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="207"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="209"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="210"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_constant_node_1ae0c5b58398f2ff9a476628ea34858893" kindref="member">type</ref><sp/>=<sp/>CT_FLOAT;</highlight></codeline>
<codeline lineno="211"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_constant_node_1ae546bb49962906e06a965381014ea7ae" kindref="member">data</ref>.<ref refid="union_constant_data_1a9c3282f50d2b4fb9752bb55fed6d1ed2" kindref="member">f</ref><sp/>=<sp/>data;</highlight></codeline>
<codeline lineno="212"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="213"><highlight class="normal">}</highlight></codeline>
<codeline lineno="214"><highlight class="normal"></highlight></codeline>
<codeline lineno="222"><highlight class="normal"><ref refid="struct_constant_node" kindref="compound">ConstantNode</ref><sp/>*createStringConstantNode(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*data)<sp/></highlight></codeline>
<codeline lineno="223"><highlight class="normal">{</highlight></codeline>
<codeline lineno="224"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_constant_node" kindref="compound">ConstantNode</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_constant_node" kindref="compound">ConstantNode</ref>));</highlight></codeline>
<codeline lineno="225"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="226"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="227"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="228"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="229"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_constant_node_1ae0c5b58398f2ff9a476628ea34858893" kindref="member">type</ref><sp/>=<sp/>CT_STRING;</highlight></codeline>
<codeline lineno="230"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_constant_node_1ae546bb49962906e06a965381014ea7ae" kindref="member">data</ref>.<ref refid="union_constant_data_1aee1ab22b8dd076717f5de146f8939b46" kindref="member">s</ref><sp/>=<sp/>data;</highlight></codeline>
<codeline lineno="231"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="232"><highlight class="normal">}</highlight></codeline>
<codeline lineno="233"><highlight class="normal"></highlight></codeline>
<codeline lineno="246"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>deleteConstantNode(<ref refid="struct_constant_node" kindref="compound">ConstantNode</ref><sp/>*node)<sp/></highlight></codeline>
<codeline lineno="247"><highlight class="normal">{</highlight></codeline>
<codeline lineno="248"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!node)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="249"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(node-&gt;<ref refid="struct_constant_node_1ae0c5b58398f2ff9a476628ea34858893" kindref="member">type</ref><sp/>==<sp/>CT_STRING)<sp/>free(node-&gt;<ref refid="struct_constant_node_1ae546bb49962906e06a965381014ea7ae" kindref="member">data</ref>.<ref refid="union_constant_data_1aee1ab22b8dd076717f5de146f8939b46" kindref="member">s</ref>);</highlight></codeline>
<codeline lineno="250"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(node);</highlight></codeline>
<codeline lineno="251"><highlight class="normal">}</highlight></codeline>
<codeline lineno="252"><highlight class="normal"></highlight></codeline>
<codeline lineno="264"><highlight class="normal"><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*createIdentifierNode(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*image,<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="265"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*fname,<sp/></highlight></codeline>
<codeline lineno="266"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>line)<sp/></highlight></codeline>
<codeline lineno="267"><highlight class="normal">{</highlight></codeline>
<codeline lineno="268"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref>));</highlight></codeline>
<codeline lineno="269"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="270"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="271"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="272"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="273"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_identifier_node_1a3e2473c7676f22d1f3beebe66f0a7688" kindref="member">image</ref><sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">)<sp/>*<sp/>(strlen(image)<sp/>+<sp/>1));</highlight></codeline>
<codeline lineno="274"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p-&gt;<ref refid="struct_identifier_node_1a3e2473c7676f22d1f3beebe66f0a7688" kindref="member">image</ref>)<sp/>{</highlight></codeline>
<codeline lineno="275"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(p);</highlight></codeline>
<codeline lineno="276"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="277"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="278"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="279"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>strcpy(p-&gt;<ref refid="struct_identifier_node_1a3e2473c7676f22d1f3beebe66f0a7688" kindref="member">image</ref>,<sp/>image);</highlight></codeline>
<codeline lineno="280"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_identifier_node_1a3e2e04a380b98e30c1227ae747edbe18" kindref="member">fname</ref><sp/>=<sp/>fname;</highlight></codeline>
<codeline lineno="281"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_identifier_node_1a64ed52f14bcfabff321d105e0a54648d" kindref="member">line</ref><sp/>=<sp/>line;</highlight></codeline>
<codeline lineno="282"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="283"><highlight class="normal">}</highlight></codeline>
<codeline lineno="284"><highlight class="normal"></highlight></codeline>
<codeline lineno="293"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>deleteIdentifierNode(<ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*node)<sp/></highlight></codeline>
<codeline lineno="294"><highlight class="normal">{</highlight></codeline>
<codeline lineno="295"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!node)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="296"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(node-&gt;<ref refid="struct_identifier_node_1a3e2473c7676f22d1f3beebe66f0a7688" kindref="member">image</ref>);</highlight></codeline>
<codeline lineno="297"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(node);</highlight></codeline>
<codeline lineno="298"><highlight class="normal">}</highlight></codeline>
<codeline lineno="299"><highlight class="normal"></highlight></codeline>
<codeline lineno="308"><highlight class="normal"><ref refid="struct_identifier_node_list" kindref="compound">IdentifierNodeList</ref><sp/>*createIdentifierNodeList(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="309"><highlight class="normal">{</highlight></codeline>
<codeline lineno="310"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_identifier_node_list" kindref="compound">IdentifierNodeList</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_identifier_node_list" kindref="compound">IdentifierNodeList</ref>));</highlight></codeline>
<codeline lineno="311"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="313"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="314"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="315"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_identifier_node_list_1a7ee19db1c4e05eafe5df277542e01dd1" kindref="member">num</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="316"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_identifier_node_list_1a61b371619c07f89846ae0780d5403dc0" kindref="member">ids</ref><sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="317"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="318"><highlight class="normal">}</highlight></codeline>
<codeline lineno="319"><highlight class="normal"></highlight></codeline>
<codeline lineno="332"><highlight class="normal"><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*addIdentifierNode(<ref refid="struct_identifier_node_list" kindref="compound">IdentifierNodeList</ref><sp/>*list,<sp/><sp/><sp/></highlight></codeline>
<codeline lineno="333"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*node)<sp/></highlight></codeline>
<codeline lineno="334"><highlight class="normal">{</highlight></codeline>
<codeline lineno="335"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>newsize<sp/>=<sp/>list-&gt;<ref refid="struct_identifier_node_list_1a7ee19db1c4e05eafe5df277542e01dd1" kindref="member">num</ref><sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="336"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*mem<sp/>=<sp/>realloc(list-&gt;<ref refid="struct_identifier_node_list_1a61b371619c07f89846ae0780d5403dc0" kindref="member">ids</ref>,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*)<sp/>*<sp/>newsize);</highlight></codeline>
<codeline lineno="337"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!mem)<sp/>{</highlight></codeline>
<codeline lineno="338"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;realloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="339"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>list-&gt;<ref refid="struct_identifier_node_list_1a61b371619c07f89846ae0780d5403dc0" kindref="member">ids</ref><sp/>=<sp/>mem;</highlight></codeline>
<codeline lineno="342"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>list-&gt;<ref refid="struct_identifier_node_list_1a61b371619c07f89846ae0780d5403dc0" kindref="member">ids</ref>[list-&gt;<ref refid="struct_identifier_node_list_1a7ee19db1c4e05eafe5df277542e01dd1" kindref="member">num</ref>]<sp/>=<sp/>node;</highlight></codeline>
<codeline lineno="343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>list-&gt;<ref refid="struct_identifier_node_list_1a7ee19db1c4e05eafe5df277542e01dd1" kindref="member">num</ref><sp/>=<sp/>newsize;</highlight></codeline>
<codeline lineno="344"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>node;</highlight></codeline>
<codeline lineno="345"><highlight class="normal">}</highlight></codeline>
<codeline lineno="346"><highlight class="normal"></highlight></codeline>
<codeline lineno="356"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>deleteIdentifierNodeList(<ref refid="struct_identifier_node_list" kindref="compound">IdentifierNodeList</ref><sp/>*list)<sp/></highlight></codeline>
<codeline lineno="357"><highlight class="normal">{</highlight></codeline>
<codeline lineno="358"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n;</highlight></codeline>
<codeline lineno="359"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!list)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="360"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(n<sp/>=<sp/>0;<sp/>n<sp/>&lt;<sp/>list-&gt;<ref refid="struct_identifier_node_list_1a7ee19db1c4e05eafe5df277542e01dd1" kindref="member">num</ref>;<sp/>n++)</highlight></codeline>
<codeline lineno="361"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(list-&gt;<ref refid="struct_identifier_node_list_1a61b371619c07f89846ae0780d5403dc0" kindref="member">ids</ref>[n]);</highlight></codeline>
<codeline lineno="362"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(list-&gt;<ref refid="struct_identifier_node_list_1a61b371619c07f89846ae0780d5403dc0" kindref="member">ids</ref>);</highlight></codeline>
<codeline lineno="363"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(list);</highlight></codeline>
<codeline lineno="364"><highlight class="normal">}</highlight></codeline>
<codeline lineno="365"><highlight class="normal"></highlight></codeline>
<codeline lineno="373"><highlight class="normal"><ref refid="struct_type_node" kindref="compound">TypeNode</ref><sp/>*createTypeNode(ConstantType<sp/>type)<sp/></highlight></codeline>
<codeline lineno="374"><highlight class="normal">{</highlight></codeline>
<codeline lineno="375"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_type_node" kindref="compound">TypeNode</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_type_node" kindref="compound">TypeNode</ref>));</highlight></codeline>
<codeline lineno="376"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="377"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="379"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="380"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_type_node_1abd5fc196a6f39c15eb33e94eec269ac7" kindref="member">type</ref><sp/>=<sp/>type;</highlight></codeline>
<codeline lineno="381"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="382"><highlight class="normal">}</highlight></codeline>
<codeline lineno="383"><highlight class="normal"></highlight></codeline>
<codeline lineno="392"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>deleteTypeNode(<ref refid="struct_type_node" kindref="compound">TypeNode</ref><sp/>*node)<sp/></highlight></codeline>
<codeline lineno="393"><highlight class="normal">{</highlight></codeline>
<codeline lineno="394"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!node)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="395"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(node);</highlight></codeline>
<codeline lineno="396"><highlight class="normal">}</highlight></codeline>
<codeline lineno="397"><highlight class="normal"></highlight></codeline>
<codeline lineno="419"><highlight class="normal"><ref refid="struct_stmt_node" kindref="compound">StmtNode</ref><sp/>*createStmtNode(StmtType<sp/>type,<sp/></highlight></codeline>
<codeline lineno="420"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*stmt)<sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="421"><highlight class="normal">{</highlight></codeline>
<codeline lineno="422"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_stmt_node" kindref="compound">StmtNode</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_stmt_node" kindref="compound">StmtNode</ref>));</highlight></codeline>
<codeline lineno="423"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="424"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="425"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="426"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="427"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_stmt_node_1a1a1a8ff13773a99c9344f5392cabfa13" kindref="member">type</ref><sp/>=<sp/>type;</highlight></codeline>
<codeline lineno="428"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_stmt_node_1abe2bb8927d8a9a26b83d855fb14837e6" kindref="member">stmt</ref><sp/>=<sp/>stmt;</highlight></codeline>
<codeline lineno="429"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="430"><highlight class="normal">}</highlight></codeline>
<codeline lineno="431"><highlight class="normal"></highlight></codeline>
<codeline lineno="440"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>deleteStmtNode(<ref refid="struct_stmt_node" kindref="compound">StmtNode</ref><sp/>*node)<sp/></highlight></codeline>
<codeline lineno="441"><highlight class="normal">{</highlight></codeline>
<codeline lineno="442"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!node)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="443"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(node-&gt;<ref refid="struct_stmt_node_1a1a1a8ff13773a99c9344f5392cabfa13" kindref="member">type</ref>)<sp/>{</highlight></codeline>
<codeline lineno="444"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ST_CAST:<sp/>{</highlight></codeline>
<codeline lineno="445"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_cast_stmt_node" kindref="compound">CastStmtNode</ref><sp/>*stmt<sp/>=<sp/>(<ref refid="struct_cast_stmt_node" kindref="compound">CastStmtNode</ref><sp/>*)node-&gt;<ref refid="struct_stmt_node_1abe2bb8927d8a9a26b83d855fb14837e6" kindref="member">stmt</ref>;</highlight></codeline>
<codeline lineno="446"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteCastStmtNode(stmt);</highlight></codeline>
<codeline lineno="447"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="448"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="449"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ST_PRINT:<sp/>{</highlight></codeline>
<codeline lineno="450"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_print_stmt_node" kindref="compound">PrintStmtNode</ref><sp/>*stmt<sp/>=<sp/>(<ref refid="struct_print_stmt_node" kindref="compound">PrintStmtNode</ref><sp/>*)node-&gt;<ref refid="struct_stmt_node_1abe2bb8927d8a9a26b83d855fb14837e6" kindref="member">stmt</ref>;</highlight></codeline>
<codeline lineno="451"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deletePrintStmtNode(stmt);</highlight></codeline>
<codeline lineno="452"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="453"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="454"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ST_INPUT:<sp/>{</highlight></codeline>
<codeline lineno="455"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_input_stmt_node" kindref="compound">InputStmtNode</ref><sp/>*stmt<sp/>=<sp/>(<ref refid="struct_input_stmt_node" kindref="compound">InputStmtNode</ref><sp/>*)node-&gt;<ref refid="struct_stmt_node_1abe2bb8927d8a9a26b83d855fb14837e6" kindref="member">stmt</ref>;</highlight></codeline>
<codeline lineno="456"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteInputStmtNode(stmt);</highlight></codeline>
<codeline lineno="457"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="458"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="459"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ST_ASSIGNMENT:<sp/>{</highlight></codeline>
<codeline lineno="460"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_assignment_stmt_node" kindref="compound">AssignmentStmtNode</ref><sp/>*stmt<sp/>=<sp/>(<ref refid="struct_assignment_stmt_node" kindref="compound">AssignmentStmtNode</ref><sp/>*)node-&gt;<ref refid="struct_stmt_node_1abe2bb8927d8a9a26b83d855fb14837e6" kindref="member">stmt</ref>;</highlight></codeline>
<codeline lineno="461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteAssignmentStmtNode(stmt);</highlight></codeline>
<codeline lineno="462"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="463"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="464"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ST_DECLARATION:<sp/>{</highlight></codeline>
<codeline lineno="465"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_declaration_stmt_node" kindref="compound">DeclarationStmtNode</ref><sp/>*stmt<sp/>=<sp/>(<ref refid="struct_declaration_stmt_node" kindref="compound">DeclarationStmtNode</ref><sp/>*)node-&gt;<ref refid="struct_stmt_node_1abe2bb8927d8a9a26b83d855fb14837e6" kindref="member">stmt</ref>;</highlight></codeline>
<codeline lineno="466"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteDeclarationStmtNode(stmt);</highlight></codeline>
<codeline lineno="467"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="468"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="469"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ST_IFTHENELSE:<sp/>{</highlight></codeline>
<codeline lineno="470"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_if_then_else_stmt_node" kindref="compound">IfThenElseStmtNode</ref><sp/>*stmt<sp/>=<sp/>(<ref refid="struct_if_then_else_stmt_node" kindref="compound">IfThenElseStmtNode</ref><sp/>*)node-&gt;<ref refid="struct_stmt_node_1abe2bb8927d8a9a26b83d855fb14837e6" kindref="member">stmt</ref>;</highlight></codeline>
<codeline lineno="471"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIfThenElseStmtNode(stmt);</highlight></codeline>
<codeline lineno="472"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="473"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="474"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ST_SWITCH:<sp/>{</highlight></codeline>
<codeline lineno="475"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_switch_stmt_node" kindref="compound">SwitchStmtNode</ref><sp/>*stmt<sp/>=<sp/>(<ref refid="struct_switch_stmt_node" kindref="compound">SwitchStmtNode</ref><sp/>*)node-&gt;<ref refid="struct_stmt_node_1abe2bb8927d8a9a26b83d855fb14837e6" kindref="member">stmt</ref>;</highlight></codeline>
<codeline lineno="476"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteSwitchStmtNode(stmt);</highlight></codeline>
<codeline lineno="477"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="478"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="479"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ST_BREAK:</highlight></codeline>
<codeline lineno="480"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;<sp/></highlight><highlight class="comment">/*<sp/>This<sp/>statement<sp/>type<sp/>does<sp/>not<sp/>have<sp/>any<sp/>content<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="481"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ST_RETURN:<sp/>{</highlight></codeline>
<codeline lineno="482"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_return_stmt_node" kindref="compound">ReturnStmtNode</ref><sp/>*stmt<sp/>=<sp/>(<ref refid="struct_return_stmt_node" kindref="compound">ReturnStmtNode</ref><sp/>*)node-&gt;<ref refid="struct_stmt_node_1abe2bb8927d8a9a26b83d855fb14837e6" kindref="member">stmt</ref>;</highlight></codeline>
<codeline lineno="483"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteReturnStmtNode(stmt);</highlight></codeline>
<codeline lineno="484"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="485"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="486"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ST_LOOP:<sp/>{</highlight></codeline>
<codeline lineno="487"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_loop_stmt_node" kindref="compound">LoopStmtNode</ref><sp/>*stmt<sp/>=<sp/>(<ref refid="struct_loop_stmt_node" kindref="compound">LoopStmtNode</ref><sp/>*)node-&gt;<ref refid="struct_stmt_node_1abe2bb8927d8a9a26b83d855fb14837e6" kindref="member">stmt</ref>;</highlight></codeline>
<codeline lineno="488"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteLoopStmtNode(stmt);</highlight></codeline>
<codeline lineno="489"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="490"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="491"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ST_EXPR:<sp/>{</highlight></codeline>
<codeline lineno="492"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*expr<sp/>=<sp/>(<ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*)node-&gt;<ref refid="struct_stmt_node_1abe2bb8927d8a9a26b83d855fb14837e6" kindref="member">stmt</ref>;</highlight></codeline>
<codeline lineno="493"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(expr);</highlight></codeline>
<codeline lineno="494"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="495"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="496"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ST_FUNCDEF:<sp/>{</highlight></codeline>
<codeline lineno="497"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref><sp/>*stmt<sp/>=<sp/>(<ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref><sp/>*)node-&gt;<ref refid="struct_stmt_node_1abe2bb8927d8a9a26b83d855fb14837e6" kindref="member">stmt</ref>;</highlight></codeline>
<codeline lineno="498"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteFuncDefStmtNode(stmt);</highlight></codeline>
<codeline lineno="499"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="500"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="501"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="502"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/></highlight><highlight class="stringliteral">&quot;Unable<sp/>to<sp/>delete<sp/>unknown<sp/>statement<sp/>type\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="503"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="504"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="505"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(node);</highlight></codeline>
<codeline lineno="506"><highlight class="normal">}</highlight></codeline>
<codeline lineno="507"><highlight class="normal"></highlight></codeline>
<codeline lineno="515"><highlight class="normal"><ref refid="struct_stmt_node_list" kindref="compound">StmtNodeList</ref><sp/>*createStmtNodeList(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="516"><highlight class="normal">{</highlight></codeline>
<codeline lineno="517"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_stmt_node_list" kindref="compound">StmtNodeList</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_stmt_node_list" kindref="compound">StmtNodeList</ref>));</highlight></codeline>
<codeline lineno="518"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="519"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="520"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="521"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="522"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_stmt_node_list_1a9036accbc55ef84c8f35058c6536fcd9" kindref="member">num</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="523"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_stmt_node_list_1a2e9faa29350794b5434f3e2e59d048a7" kindref="member">stmts</ref><sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="524"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="525"><highlight class="normal">}</highlight></codeline>
<codeline lineno="526"><highlight class="normal"></highlight></codeline>
<codeline lineno="538"><highlight class="normal"><ref refid="struct_stmt_node" kindref="compound">StmtNode</ref><sp/>*addStmtNode(<ref refid="struct_stmt_node_list" kindref="compound">StmtNodeList</ref><sp/>*list,<sp/></highlight></codeline>
<codeline lineno="539"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_stmt_node" kindref="compound">StmtNode</ref><sp/>*node)<sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="540"><highlight class="normal">{</highlight></codeline>
<codeline lineno="541"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>newsize<sp/>=<sp/>list-&gt;<ref refid="struct_stmt_node_list_1a9036accbc55ef84c8f35058c6536fcd9" kindref="member">num</ref><sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="542"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*mem<sp/>=<sp/>realloc(list-&gt;<ref refid="struct_stmt_node_list_1a2e9faa29350794b5434f3e2e59d048a7" kindref="member">stmts</ref>,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_stmt_node" kindref="compound">StmtNode</ref><sp/>*)<sp/>*<sp/>newsize);</highlight></codeline>
<codeline lineno="543"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!mem)<sp/>{</highlight></codeline>
<codeline lineno="544"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;realloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="545"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="546"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="547"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>list-&gt;<ref refid="struct_stmt_node_list_1a2e9faa29350794b5434f3e2e59d048a7" kindref="member">stmts</ref><sp/>=<sp/>mem;</highlight></codeline>
<codeline lineno="548"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>list-&gt;<ref refid="struct_stmt_node_list_1a2e9faa29350794b5434f3e2e59d048a7" kindref="member">stmts</ref>[list-&gt;<ref refid="struct_stmt_node_list_1a9036accbc55ef84c8f35058c6536fcd9" kindref="member">num</ref>]<sp/>=<sp/>node;</highlight></codeline>
<codeline lineno="549"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>list-&gt;<ref refid="struct_stmt_node_list_1a9036accbc55ef84c8f35058c6536fcd9" kindref="member">num</ref><sp/>=<sp/>newsize;</highlight></codeline>
<codeline lineno="550"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>node;</highlight></codeline>
<codeline lineno="551"><highlight class="normal">}</highlight></codeline>
<codeline lineno="552"><highlight class="normal"></highlight></codeline>
<codeline lineno="562"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>deleteStmtNodeList(<ref refid="struct_stmt_node_list" kindref="compound">StmtNodeList</ref><sp/>*list)<sp/></highlight></codeline>
<codeline lineno="563"><highlight class="normal">{</highlight></codeline>
<codeline lineno="564"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n;</highlight></codeline>
<codeline lineno="565"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!list)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="566"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(n<sp/>=<sp/>0;<sp/>n<sp/>&lt;<sp/>list-&gt;<ref refid="struct_stmt_node_list_1a9036accbc55ef84c8f35058c6536fcd9" kindref="member">num</ref>;<sp/>n++)</highlight></codeline>
<codeline lineno="567"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteStmtNode(list-&gt;<ref refid="struct_stmt_node_list_1a2e9faa29350794b5434f3e2e59d048a7" kindref="member">stmts</ref>[n]);</highlight></codeline>
<codeline lineno="568"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(list-&gt;<ref refid="struct_stmt_node_list_1a2e9faa29350794b5434f3e2e59d048a7" kindref="member">stmts</ref>);</highlight></codeline>
<codeline lineno="569"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(list);</highlight></codeline>
<codeline lineno="570"><highlight class="normal">}</highlight></codeline>
<codeline lineno="571"><highlight class="normal"></highlight></codeline>
<codeline lineno="582"><highlight class="normal"><ref refid="struct_cast_stmt_node" kindref="compound">CastStmtNode</ref><sp/>*createCastStmtNode(<ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*target,<sp/></highlight></codeline>
<codeline lineno="583"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_type_node" kindref="compound">TypeNode</ref><sp/>*newtype)<sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="584"><highlight class="normal">{</highlight></codeline>
<codeline lineno="585"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_cast_stmt_node" kindref="compound">CastStmtNode</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_cast_stmt_node" kindref="compound">CastStmtNode</ref>));</highlight></codeline>
<codeline lineno="586"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="587"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="588"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="589"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="590"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_cast_stmt_node_1a89d56358f0a8fc4d4fb0df7029ea494e" kindref="member">target</ref><sp/>=<sp/>target;</highlight></codeline>
<codeline lineno="591"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_cast_stmt_node_1adbeebc6cefa4f2cb92079b82cb4f4df8" kindref="member">newtype</ref><sp/>=<sp/>newtype;</highlight></codeline>
<codeline lineno="592"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="593"><highlight class="normal">}</highlight></codeline>
<codeline lineno="594"><highlight class="normal"></highlight></codeline>
<codeline lineno="603"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>deleteCastStmtNode(<ref refid="struct_cast_stmt_node" kindref="compound">CastStmtNode</ref><sp/>*node)<sp/></highlight></codeline>
<codeline lineno="604"><highlight class="normal">{</highlight></codeline>
<codeline lineno="605"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!node)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="606"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(node-&gt;<ref refid="struct_cast_stmt_node_1a89d56358f0a8fc4d4fb0df7029ea494e" kindref="member">target</ref>);</highlight></codeline>
<codeline lineno="607"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteTypeNode(node-&gt;<ref refid="struct_cast_stmt_node_1adbeebc6cefa4f2cb92079b82cb4f4df8" kindref="member">newtype</ref>);</highlight></codeline>
<codeline lineno="608"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(node);</highlight></codeline>
<codeline lineno="609"><highlight class="normal">}</highlight></codeline>
<codeline lineno="610"><highlight class="normal"></highlight></codeline>
<codeline lineno="621"><highlight class="normal"><ref refid="struct_print_stmt_node" kindref="compound">PrintStmtNode</ref><sp/>*createPrintStmtNode(<ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref><sp/>*args,<sp/></highlight></codeline>
<codeline lineno="622"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nonl)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="623"><highlight class="normal">{</highlight></codeline>
<codeline lineno="624"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_print_stmt_node" kindref="compound">PrintStmtNode</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_print_stmt_node" kindref="compound">PrintStmtNode</ref>));</highlight></codeline>
<codeline lineno="625"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="626"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="627"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="628"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="629"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_print_stmt_node_1a9ee87b79d331dc05b6a4bb27462a5f69" kindref="member">args</ref><sp/>=<sp/>args;</highlight></codeline>
<codeline lineno="630"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_print_stmt_node_1a147ba34eeda7bcfb39f2846a678d091c" kindref="member">nonl</ref><sp/>=<sp/>nonl;</highlight></codeline>
<codeline lineno="631"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="632"><highlight class="normal">}</highlight></codeline>
<codeline lineno="633"><highlight class="normal"></highlight></codeline>
<codeline lineno="642"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>deletePrintStmtNode(<ref refid="struct_print_stmt_node" kindref="compound">PrintStmtNode</ref><sp/>*node)<sp/></highlight></codeline>
<codeline lineno="643"><highlight class="normal">{</highlight></codeline>
<codeline lineno="644"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!node)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="645"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(node-&gt;<ref refid="struct_print_stmt_node_1a9ee87b79d331dc05b6a4bb27462a5f69" kindref="member">args</ref>);</highlight></codeline>
<codeline lineno="646"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(node);</highlight></codeline>
<codeline lineno="647"><highlight class="normal">}</highlight></codeline>
<codeline lineno="648"><highlight class="normal"></highlight></codeline>
<codeline lineno="658"><highlight class="normal"><ref refid="struct_input_stmt_node" kindref="compound">InputStmtNode</ref><sp/>*createInputStmtNode(<ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*target)<sp/></highlight></codeline>
<codeline lineno="659"><highlight class="normal">{</highlight></codeline>
<codeline lineno="660"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_input_stmt_node" kindref="compound">InputStmtNode</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_input_stmt_node" kindref="compound">InputStmtNode</ref>));</highlight></codeline>
<codeline lineno="661"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="662"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="663"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="664"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="665"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_input_stmt_node_1ad7cb247683faf94a9da01d08055349f2" kindref="member">target</ref><sp/>=<sp/>target;</highlight></codeline>
<codeline lineno="666"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="667"><highlight class="normal">}</highlight></codeline>
<codeline lineno="668"><highlight class="normal"></highlight></codeline>
<codeline lineno="677"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>deleteInputStmtNode(<ref refid="struct_input_stmt_node" kindref="compound">InputStmtNode</ref><sp/>*node)<sp/></highlight></codeline>
<codeline lineno="678"><highlight class="normal">{</highlight></codeline>
<codeline lineno="679"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!node)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="680"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(node-&gt;<ref refid="struct_input_stmt_node_1ad7cb247683faf94a9da01d08055349f2" kindref="member">target</ref>);</highlight></codeline>
<codeline lineno="681"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(node);</highlight></codeline>
<codeline lineno="682"><highlight class="normal">}</highlight></codeline>
<codeline lineno="683"><highlight class="normal"></highlight></codeline>
<codeline lineno="695"><highlight class="normal"><ref refid="struct_assignment_stmt_node" kindref="compound">AssignmentStmtNode</ref><sp/>*createAssignmentStmtNode(<ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*target,<sp/></highlight></codeline>
<codeline lineno="696"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*expr)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="697"><highlight class="normal">{</highlight></codeline>
<codeline lineno="698"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_assignment_stmt_node" kindref="compound">AssignmentStmtNode</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_assignment_stmt_node" kindref="compound">AssignmentStmtNode</ref>));</highlight></codeline>
<codeline lineno="699"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="700"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="701"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="702"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="703"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_assignment_stmt_node_1a6bdcf7c297f54d4269849cb96c8161a6" kindref="member">target</ref><sp/>=<sp/>target;</highlight></codeline>
<codeline lineno="704"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_assignment_stmt_node_1af25b11d4ed4159da853c540641f0db24" kindref="member">expr</ref><sp/>=<sp/>expr;</highlight></codeline>
<codeline lineno="705"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="706"><highlight class="normal">}</highlight></codeline>
<codeline lineno="707"><highlight class="normal"></highlight></codeline>
<codeline lineno="716"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>deleteAssignmentStmtNode(<ref refid="struct_assignment_stmt_node" kindref="compound">AssignmentStmtNode</ref><sp/>*node)<sp/></highlight></codeline>
<codeline lineno="717"><highlight class="normal">{</highlight></codeline>
<codeline lineno="718"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!node)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="719"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(node-&gt;<ref refid="struct_assignment_stmt_node_1a6bdcf7c297f54d4269849cb96c8161a6" kindref="member">target</ref>);</highlight></codeline>
<codeline lineno="720"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(node-&gt;<ref refid="struct_assignment_stmt_node_1af25b11d4ed4159da853c540641f0db24" kindref="member">expr</ref>);</highlight></codeline>
<codeline lineno="721"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(node);</highlight></codeline>
<codeline lineno="722"><highlight class="normal">}</highlight></codeline>
<codeline lineno="723"><highlight class="normal"></highlight></codeline>
<codeline lineno="736"><highlight class="normal"><ref refid="struct_declaration_stmt_node" kindref="compound">DeclarationStmtNode</ref><sp/>*createDeclarationStmtNode(<ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*scope,<sp/><sp/></highlight></codeline>
<codeline lineno="737"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*target,<sp/></highlight></codeline>
<codeline lineno="738"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*expr)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="739"><highlight class="normal">{</highlight></codeline>
<codeline lineno="740"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_declaration_stmt_node" kindref="compound">DeclarationStmtNode</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_declaration_stmt_node" kindref="compound">DeclarationStmtNode</ref>));</highlight></codeline>
<codeline lineno="741"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="742"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="743"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="744"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="745"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_declaration_stmt_node_1ab52e3859c15ef8b651f330bcd963c56c" kindref="member">scope</ref><sp/>=<sp/>scope;</highlight></codeline>
<codeline lineno="746"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_declaration_stmt_node_1a6fed156d07803ffd41487e873bcef98f" kindref="member">target</ref><sp/>=<sp/>target;</highlight></codeline>
<codeline lineno="747"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_declaration_stmt_node_1aba3f89fdd66c4b0264490aa639a6bd6f" kindref="member">expr</ref><sp/>=<sp/>expr;</highlight></codeline>
<codeline lineno="748"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="749"><highlight class="normal">}</highlight></codeline>
<codeline lineno="750"><highlight class="normal"></highlight></codeline>
<codeline lineno="759"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>deleteDeclarationStmtNode(<ref refid="struct_declaration_stmt_node" kindref="compound">DeclarationStmtNode</ref><sp/>*node)<sp/></highlight></codeline>
<codeline lineno="760"><highlight class="normal">{</highlight></codeline>
<codeline lineno="761"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!node)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="762"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(node-&gt;<ref refid="struct_declaration_stmt_node_1ab52e3859c15ef8b651f330bcd963c56c" kindref="member">scope</ref>);</highlight></codeline>
<codeline lineno="763"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(node-&gt;<ref refid="struct_declaration_stmt_node_1a6fed156d07803ffd41487e873bcef98f" kindref="member">target</ref>);</highlight></codeline>
<codeline lineno="764"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(node-&gt;<ref refid="struct_declaration_stmt_node_1aba3f89fdd66c4b0264490aa639a6bd6f" kindref="member">expr</ref>);</highlight></codeline>
<codeline lineno="765"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(node);</highlight></codeline>
<codeline lineno="766"><highlight class="normal">}</highlight></codeline>
<codeline lineno="767"><highlight class="normal"></highlight></codeline>
<codeline lineno="783"><highlight class="normal"><ref refid="struct_if_then_else_stmt_node" kindref="compound">IfThenElseStmtNode</ref><sp/>*createIfThenElseStmtNode(<ref refid="struct_block_node" kindref="compound">BlockNode</ref><sp/>*yes,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="784"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_block_node" kindref="compound">BlockNode</ref><sp/>*no,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="785"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref><sp/>*guards,<sp/><sp/></highlight></codeline>
<codeline lineno="786"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_block_node_list" kindref="compound">BlockNodeList</ref><sp/>*blocks)<sp/></highlight></codeline>
<codeline lineno="787"><highlight class="normal">{</highlight></codeline>
<codeline lineno="788"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_if_then_else_stmt_node" kindref="compound">IfThenElseStmtNode</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_if_then_else_stmt_node" kindref="compound">IfThenElseStmtNode</ref>));</highlight></codeline>
<codeline lineno="789"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="790"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="791"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="792"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="793"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_if_then_else_stmt_node_1ae28470757cf61cab67dd9096114f4710" kindref="member">yes</ref><sp/>=<sp/>yes;</highlight></codeline>
<codeline lineno="794"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_if_then_else_stmt_node_1aeb7d6e0fb8dad0d6e894bcdc887306fe" kindref="member">no</ref><sp/>=<sp/>no;</highlight></codeline>
<codeline lineno="795"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_if_then_else_stmt_node_1ad94295fb6d16e9815a85e0d8e930f079" kindref="member">guards</ref><sp/>=<sp/>guards;</highlight></codeline>
<codeline lineno="796"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_if_then_else_stmt_node_1ab4b9831a1e7db13c206997a45ee84a95" kindref="member">blocks</ref><sp/>=<sp/>blocks;</highlight></codeline>
<codeline lineno="797"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="798"><highlight class="normal">}</highlight></codeline>
<codeline lineno="799"><highlight class="normal"></highlight></codeline>
<codeline lineno="808"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>deleteIfThenElseStmtNode(<ref refid="struct_if_then_else_stmt_node" kindref="compound">IfThenElseStmtNode</ref><sp/>*node)<sp/></highlight></codeline>
<codeline lineno="809"><highlight class="normal">{</highlight></codeline>
<codeline lineno="810"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!node)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="811"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(node-&gt;<ref refid="struct_if_then_else_stmt_node_1ae28470757cf61cab67dd9096114f4710" kindref="member">yes</ref>);</highlight></codeline>
<codeline lineno="812"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(node-&gt;<ref refid="struct_if_then_else_stmt_node_1aeb7d6e0fb8dad0d6e894bcdc887306fe" kindref="member">no</ref>);</highlight></codeline>
<codeline lineno="813"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(node-&gt;<ref refid="struct_if_then_else_stmt_node_1ad94295fb6d16e9815a85e0d8e930f079" kindref="member">guards</ref>);</highlight></codeline>
<codeline lineno="814"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNodeList(node-&gt;<ref refid="struct_if_then_else_stmt_node_1ab4b9831a1e7db13c206997a45ee84a95" kindref="member">blocks</ref>);</highlight></codeline>
<codeline lineno="815"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(node);</highlight></codeline>
<codeline lineno="816"><highlight class="normal">}</highlight></codeline>
<codeline lineno="817"><highlight class="normal"></highlight></codeline>
<codeline lineno="831"><highlight class="normal"><ref refid="struct_switch_stmt_node" kindref="compound">SwitchStmtNode</ref><sp/>*createSwitchStmtNode(<ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref><sp/>*guards,<sp/><sp/></highlight></codeline>
<codeline lineno="832"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_block_node_list" kindref="compound">BlockNodeList</ref><sp/>*blocks,<sp/></highlight></codeline>
<codeline lineno="833"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_block_node" kindref="compound">BlockNode</ref><sp/>*def)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="834"><highlight class="normal">{</highlight></codeline>
<codeline lineno="835"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_switch_stmt_node" kindref="compound">SwitchStmtNode</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_switch_stmt_node" kindref="compound">SwitchStmtNode</ref>));</highlight></codeline>
<codeline lineno="836"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="837"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="838"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="839"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="840"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_switch_stmt_node_1a125319a6fd02d72d96d41193daffb4a2" kindref="member">guards</ref><sp/>=<sp/>guards;</highlight></codeline>
<codeline lineno="841"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_switch_stmt_node_1a6cdb5c66044261b28302b6ca682d7564" kindref="member">blocks</ref><sp/>=<sp/>blocks;</highlight></codeline>
<codeline lineno="842"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_switch_stmt_node_1ad75de1632a46c451d251959e56d53d44" kindref="member">def</ref><sp/>=<sp/>def;</highlight></codeline>
<codeline lineno="843"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="844"><highlight class="normal">}</highlight></codeline>
<codeline lineno="845"><highlight class="normal"></highlight></codeline>
<codeline lineno="854"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>deleteSwitchStmtNode(<ref refid="struct_switch_stmt_node" kindref="compound">SwitchStmtNode</ref><sp/>*node)<sp/></highlight></codeline>
<codeline lineno="855"><highlight class="normal">{</highlight></codeline>
<codeline lineno="856"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!node)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="857"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(node-&gt;<ref refid="struct_switch_stmt_node_1a125319a6fd02d72d96d41193daffb4a2" kindref="member">guards</ref>);</highlight></codeline>
<codeline lineno="858"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNodeList(node-&gt;<ref refid="struct_switch_stmt_node_1a6cdb5c66044261b28302b6ca682d7564" kindref="member">blocks</ref>);</highlight></codeline>
<codeline lineno="859"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(node-&gt;<ref refid="struct_switch_stmt_node_1ad75de1632a46c451d251959e56d53d44" kindref="member">def</ref>);</highlight></codeline>
<codeline lineno="860"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(node);</highlight></codeline>
<codeline lineno="861"><highlight class="normal">}</highlight></codeline>
<codeline lineno="862"><highlight class="normal"></highlight></codeline>
<codeline lineno="872"><highlight class="normal"><ref refid="struct_return_stmt_node" kindref="compound">ReturnStmtNode</ref><sp/>*createReturnStmtNode(<ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*value)<sp/></highlight></codeline>
<codeline lineno="873"><highlight class="normal">{</highlight></codeline>
<codeline lineno="874"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_return_stmt_node" kindref="compound">ReturnStmtNode</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_return_stmt_node" kindref="compound">ReturnStmtNode</ref>));</highlight></codeline>
<codeline lineno="875"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="876"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="877"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="878"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="879"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_return_stmt_node_1ac610b54406ae3bc54e3d5c4e9fcb1d2e" kindref="member">value</ref><sp/>=<sp/>value;</highlight></codeline>
<codeline lineno="880"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="881"><highlight class="normal">}</highlight></codeline>
<codeline lineno="882"><highlight class="normal"></highlight></codeline>
<codeline lineno="891"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>deleteReturnStmtNode(<ref refid="struct_return_stmt_node" kindref="compound">ReturnStmtNode</ref><sp/>*node)<sp/></highlight></codeline>
<codeline lineno="892"><highlight class="normal">{</highlight></codeline>
<codeline lineno="893"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!node)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="894"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(node-&gt;<ref refid="struct_return_stmt_node_1ac610b54406ae3bc54e3d5c4e9fcb1d2e" kindref="member">value</ref>);</highlight></codeline>
<codeline lineno="895"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(node);</highlight></codeline>
<codeline lineno="896"><highlight class="normal">}</highlight></codeline>
<codeline lineno="897"><highlight class="normal"></highlight></codeline>
<codeline lineno="911"><highlight class="normal"><ref refid="struct_loop_stmt_node" kindref="compound">LoopStmtNode</ref><sp/>*createLoopStmtNode(<ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*name,<sp/></highlight></codeline>
<codeline lineno="912"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*var,<sp/><sp/></highlight></codeline>
<codeline lineno="913"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*guard,<sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="914"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*update,<sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="915"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_block_node" kindref="compound">BlockNode</ref><sp/>*body)<sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="916"><highlight class="normal">{</highlight></codeline>
<codeline lineno="917"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_loop_stmt_node" kindref="compound">LoopStmtNode</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_loop_stmt_node" kindref="compound">LoopStmtNode</ref>));</highlight></codeline>
<codeline lineno="918"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="919"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="920"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="921"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="922"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_loop_stmt_node_1a36b401d6c4fd2c16a68de026b99187f3" kindref="member">name</ref><sp/>=<sp/>name;</highlight></codeline>
<codeline lineno="923"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_loop_stmt_node_1afb3820072966231fd1d43eea8ebd9234" kindref="member">var</ref><sp/>=<sp/>var;</highlight></codeline>
<codeline lineno="924"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_loop_stmt_node_1a53a86fb7f989cf43f54192b8f3ad6c1a" kindref="member">guard</ref><sp/>=<sp/>guard;</highlight></codeline>
<codeline lineno="925"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_loop_stmt_node_1a0400ab555fff51b09f79c495af20f37f" kindref="member">update</ref><sp/>=<sp/>update;</highlight></codeline>
<codeline lineno="926"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_loop_stmt_node_1a6844fd9206ed5d6b4fd48fc1365969aa" kindref="member">body</ref><sp/>=<sp/>body;</highlight></codeline>
<codeline lineno="927"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="928"><highlight class="normal">}</highlight></codeline>
<codeline lineno="929"><highlight class="normal"></highlight></codeline>
<codeline lineno="938"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>deleteLoopStmtNode(<ref refid="struct_loop_stmt_node" kindref="compound">LoopStmtNode</ref><sp/>*node)<sp/></highlight></codeline>
<codeline lineno="939"><highlight class="normal">{</highlight></codeline>
<codeline lineno="940"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!node)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="941"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(node-&gt;<ref refid="struct_loop_stmt_node_1a36b401d6c4fd2c16a68de026b99187f3" kindref="member">name</ref>);</highlight></codeline>
<codeline lineno="942"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(node-&gt;<ref refid="struct_loop_stmt_node_1afb3820072966231fd1d43eea8ebd9234" kindref="member">var</ref>);</highlight></codeline>
<codeline lineno="943"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(node-&gt;<ref refid="struct_loop_stmt_node_1a53a86fb7f989cf43f54192b8f3ad6c1a" kindref="member">guard</ref>);</highlight></codeline>
<codeline lineno="944"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(node-&gt;<ref refid="struct_loop_stmt_node_1a0400ab555fff51b09f79c495af20f37f" kindref="member">update</ref>);</highlight></codeline>
<codeline lineno="945"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(node-&gt;<ref refid="struct_loop_stmt_node_1a6844fd9206ed5d6b4fd48fc1365969aa" kindref="member">body</ref>);</highlight></codeline>
<codeline lineno="946"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(node);</highlight></codeline>
<codeline lineno="947"><highlight class="normal">}</highlight></codeline>
<codeline lineno="948"><highlight class="normal"></highlight></codeline>
<codeline lineno="963"><highlight class="normal"><ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref><sp/>*createFuncDefStmtNode(<ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*scope,<sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="964"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*name,<sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="965"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_identifier_node_list" kindref="compound">IdentifierNodeList</ref><sp/>*args,<sp/></highlight></codeline>
<codeline lineno="966"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_block_node" kindref="compound">BlockNode</ref><sp/>*body)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="967"><highlight class="normal">{</highlight></codeline>
<codeline lineno="968"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref>));</highlight></codeline>
<codeline lineno="969"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="970"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="971"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="972"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="973"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_func_def_stmt_node_1a545e8a727dbe8786ab90afa0a4608d68" kindref="member">scope</ref><sp/>=<sp/>scope;</highlight></codeline>
<codeline lineno="974"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_func_def_stmt_node_1ab047936127219724532e25ba6890265a" kindref="member">name</ref><sp/>=<sp/>name;</highlight></codeline>
<codeline lineno="975"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_func_def_stmt_node_1a2a9f4d580b7252e5576873d2252a187a" kindref="member">args</ref><sp/>=<sp/>args;</highlight></codeline>
<codeline lineno="976"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_func_def_stmt_node_1a9e50b6a41f7abe43b433fe4fd714b002" kindref="member">body</ref><sp/>=<sp/>body;</highlight></codeline>
<codeline lineno="977"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="978"><highlight class="normal">}</highlight></codeline>
<codeline lineno="979"><highlight class="normal"></highlight></codeline>
<codeline lineno="988"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>deleteFuncDefStmtNode(<ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref><sp/>*node)<sp/></highlight></codeline>
<codeline lineno="989"><highlight class="normal">{</highlight></codeline>
<codeline lineno="990"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!node)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="991"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(node-&gt;<ref refid="struct_func_def_stmt_node_1a545e8a727dbe8786ab90afa0a4608d68" kindref="member">scope</ref>);</highlight></codeline>
<codeline lineno="992"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(node-&gt;<ref refid="struct_func_def_stmt_node_1ab047936127219724532e25ba6890265a" kindref="member">name</ref>);</highlight></codeline>
<codeline lineno="993"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNodeList(node-&gt;<ref refid="struct_func_def_stmt_node_1a2a9f4d580b7252e5576873d2252a187a" kindref="member">args</ref>);</highlight></codeline>
<codeline lineno="994"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(node-&gt;<ref refid="struct_func_def_stmt_node_1a9e50b6a41f7abe43b433fe4fd714b002" kindref="member">body</ref>);</highlight></codeline>
<codeline lineno="995"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(node);</highlight></codeline>
<codeline lineno="996"><highlight class="normal">}</highlight></codeline>
<codeline lineno="997"><highlight class="normal"></highlight></codeline>
<codeline lineno="1014"><highlight class="normal"><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*createExprNode(ExprType<sp/>type,<sp/></highlight></codeline>
<codeline lineno="1015"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*expr)<sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1016"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1017"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_expr_node" kindref="compound">ExprNode</ref>));</highlight></codeline>
<codeline lineno="1018"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="1019"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1020"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1021"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1022"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_expr_node_1ab5f285d791068c69dbca0610d8c36c99" kindref="member">type</ref><sp/>=<sp/>type;</highlight></codeline>
<codeline lineno="1023"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_expr_node_1a2c6ff3dccfa2e543a46e01763adab3a8" kindref="member">expr</ref><sp/>=<sp/>expr;</highlight></codeline>
<codeline lineno="1024"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="1025"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1026"><highlight class="normal"></highlight></codeline>
<codeline lineno="1035"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>deleteExprNode(<ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*node)<sp/></highlight></codeline>
<codeline lineno="1036"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1037"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!node)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="1038"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(node-&gt;<ref refid="struct_expr_node_1ab5f285d791068c69dbca0610d8c36c99" kindref="member">type</ref>)<sp/>{</highlight></codeline>
<codeline lineno="1039"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ET_CAST:</highlight></codeline>
<codeline lineno="1040"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteCastExprNode((<ref refid="struct_cast_expr_node" kindref="compound">CastExprNode</ref><sp/>*)node-&gt;<ref refid="struct_expr_node_1a2c6ff3dccfa2e543a46e01763adab3a8" kindref="member">expr</ref>);</highlight></codeline>
<codeline lineno="1041"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="1042"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ET_CONSTANT:</highlight></codeline>
<codeline lineno="1043"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteConstantNode((<ref refid="struct_constant_node" kindref="compound">ConstantNode</ref><sp/>*)node-&gt;<ref refid="struct_expr_node_1a2c6ff3dccfa2e543a46e01763adab3a8" kindref="member">expr</ref>);</highlight></codeline>
<codeline lineno="1044"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="1045"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ET_IDENTIFIER:</highlight></codeline>
<codeline lineno="1046"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode((<ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*)node-&gt;<ref refid="struct_expr_node_1a2c6ff3dccfa2e543a46e01763adab3a8" kindref="member">expr</ref>);</highlight></codeline>
<codeline lineno="1047"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="1048"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ET_FUNCCALL:</highlight></codeline>
<codeline lineno="1049"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteFuncCallExprNode((<ref refid="struct_func_call_expr_node" kindref="compound">FuncCallExprNode</ref><sp/>*)node-&gt;<ref refid="struct_expr_node_1a2c6ff3dccfa2e543a46e01763adab3a8" kindref="member">expr</ref>);</highlight></codeline>
<codeline lineno="1050"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="1051"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ET_OP:</highlight></codeline>
<codeline lineno="1052"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteOpExprNode((<ref refid="struct_op_expr_node" kindref="compound">OpExprNode</ref><sp/>*)node-&gt;<ref refid="struct_expr_node_1a2c6ff3dccfa2e543a46e01763adab3a8" kindref="member">expr</ref>);</highlight></codeline>
<codeline lineno="1053"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="1054"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>ET_IMPVAR:</highlight></codeline>
<codeline lineno="1055"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;<sp/></highlight><highlight class="comment">/*<sp/>This<sp/>expression<sp/>type<sp/>does<sp/>not<sp/>have<sp/>any<sp/>content<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1056"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline lineno="1057"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/></highlight><highlight class="stringliteral">&quot;Unable<sp/>to<sp/>delete<sp/>unknown<sp/>expression<sp/>type\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1058"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="1059"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1060"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(node);</highlight></codeline>
<codeline lineno="1061"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1062"><highlight class="normal"></highlight></codeline>
<codeline lineno="1070"><highlight class="normal"><ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref><sp/>*createExprNodeList(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="1071"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1072"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref>));</highlight></codeline>
<codeline lineno="1073"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="1074"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1075"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1076"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1077"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_expr_node_list_1a60f9bbe230725287369033df733a2b04" kindref="member">num</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="1078"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_expr_node_list_1a10ae95f2facec652ba79e0bb5c9298c1" kindref="member">exprs</ref><sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1079"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="1080"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1081"><highlight class="normal"></highlight></codeline>
<codeline lineno="1094"><highlight class="normal"><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*addExprNode(<ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref><sp/>*list,<sp/></highlight></codeline>
<codeline lineno="1095"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*node)<sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1096"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1097"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>newsize<sp/>=<sp/>list-&gt;<ref refid="struct_expr_node_list_1a60f9bbe230725287369033df733a2b04" kindref="member">num</ref><sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="1098"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*mem<sp/>=<sp/>realloc(list-&gt;<ref refid="struct_expr_node_list_1a10ae95f2facec652ba79e0bb5c9298c1" kindref="member">exprs</ref>,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*)<sp/>*<sp/>newsize);</highlight></codeline>
<codeline lineno="1099"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!mem)<sp/>{</highlight></codeline>
<codeline lineno="1100"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;realloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1101"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1102"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>list-&gt;<ref refid="struct_expr_node_list_1a10ae95f2facec652ba79e0bb5c9298c1" kindref="member">exprs</ref><sp/>=<sp/>mem;</highlight></codeline>
<codeline lineno="1104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>list-&gt;<ref refid="struct_expr_node_list_1a10ae95f2facec652ba79e0bb5c9298c1" kindref="member">exprs</ref>[list-&gt;<ref refid="struct_expr_node_list_1a60f9bbe230725287369033df733a2b04" kindref="member">num</ref>]<sp/>=<sp/>node;</highlight></codeline>
<codeline lineno="1105"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>list-&gt;<ref refid="struct_expr_node_list_1a60f9bbe230725287369033df733a2b04" kindref="member">num</ref><sp/>=<sp/>newsize;</highlight></codeline>
<codeline lineno="1106"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>node;</highlight></codeline>
<codeline lineno="1107"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1108"><highlight class="normal"></highlight></codeline>
<codeline lineno="1118"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>deleteExprNodeList(<ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref><sp/>*list)<sp/></highlight></codeline>
<codeline lineno="1119"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1120"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n;</highlight></codeline>
<codeline lineno="1121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!list)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="1122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(n<sp/>=<sp/>0;<sp/>n<sp/>&lt;<sp/>list-&gt;<ref refid="struct_expr_node_list_1a60f9bbe230725287369033df733a2b04" kindref="member">num</ref>;<sp/>n++)</highlight></codeline>
<codeline lineno="1123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(list-&gt;<ref refid="struct_expr_node_list_1a10ae95f2facec652ba79e0bb5c9298c1" kindref="member">exprs</ref>[n]);</highlight></codeline>
<codeline lineno="1124"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(list-&gt;<ref refid="struct_expr_node_list_1a10ae95f2facec652ba79e0bb5c9298c1" kindref="member">exprs</ref>);</highlight></codeline>
<codeline lineno="1125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(list);</highlight></codeline>
<codeline lineno="1126"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1127"><highlight class="normal"></highlight></codeline>
<codeline lineno="1138"><highlight class="normal"><ref refid="struct_cast_expr_node" kindref="compound">CastExprNode</ref><sp/>*createCastExprNode(<ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*target,<sp/><sp/></highlight></codeline>
<codeline lineno="1139"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_type_node" kindref="compound">TypeNode</ref><sp/>*newtype)<sp/></highlight></codeline>
<codeline lineno="1140"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1141"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_cast_expr_node" kindref="compound">CastExprNode</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_cast_expr_node" kindref="compound">CastExprNode</ref>));</highlight></codeline>
<codeline lineno="1142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="1143"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1144"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_cast_expr_node_1a90d1ac82b5b4a63a6842fc4e33f4e3bb" kindref="member">target</ref><sp/>=<sp/>target;</highlight></codeline>
<codeline lineno="1147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_cast_expr_node_1a0198b8265e221f2a52609a2d117585ef" kindref="member">newtype</ref><sp/>=<sp/>newtype;</highlight></codeline>
<codeline lineno="1148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="1149"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1150"><highlight class="normal"></highlight></codeline>
<codeline lineno="1159"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>deleteCastExprNode(<ref refid="struct_cast_expr_node" kindref="compound">CastExprNode</ref><sp/>*node)<sp/></highlight></codeline>
<codeline lineno="1160"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1161"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!node)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="1162"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(node-&gt;<ref refid="struct_cast_expr_node_1a90d1ac82b5b4a63a6842fc4e33f4e3bb" kindref="member">target</ref>);</highlight></codeline>
<codeline lineno="1163"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteTypeNode(node-&gt;<ref refid="struct_cast_expr_node_1a0198b8265e221f2a52609a2d117585ef" kindref="member">newtype</ref>);</highlight></codeline>
<codeline lineno="1164"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(node);</highlight></codeline>
<codeline lineno="1165"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1166"><highlight class="normal"></highlight></codeline>
<codeline lineno="1179"><highlight class="normal"><ref refid="struct_func_call_expr_node" kindref="compound">FuncCallExprNode</ref><sp/>*createFuncCallExprNode(<ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref><sp/>*def,<sp/></highlight></codeline>
<codeline lineno="1180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref><sp/>*args)<sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1181"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_func_call_expr_node" kindref="compound">FuncCallExprNode</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_func_call_expr_node" kindref="compound">FuncCallExprNode</ref>));</highlight></codeline>
<codeline lineno="1183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="1184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1187"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_func_call_expr_node_1aa2a85cf9427647c0e922221095c00e94" kindref="member">def</ref><sp/>=<sp/>def;</highlight></codeline>
<codeline lineno="1188"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_func_call_expr_node_1a559b2108d83b11b46584b85f6fd1b12b" kindref="member">args</ref><sp/>=<sp/>args;</highlight></codeline>
<codeline lineno="1189"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="1190"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1191"><highlight class="normal"></highlight></codeline>
<codeline lineno="1200"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>deleteFuncCallExprNode(<ref refid="struct_func_call_expr_node" kindref="compound">FuncCallExprNode</ref><sp/>*node)<sp/></highlight></codeline>
<codeline lineno="1201"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!node)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="1203"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(node-&gt;<ref refid="struct_func_call_expr_node_1a559b2108d83b11b46584b85f6fd1b12b" kindref="member">args</ref>);</highlight></codeline>
<codeline lineno="1204"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(node);</highlight></codeline>
<codeline lineno="1205"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1206"><highlight class="normal"></highlight></codeline>
<codeline lineno="1217"><highlight class="normal"><ref refid="struct_op_expr_node" kindref="compound">OpExprNode</ref><sp/>*createOpExprNode(OpType<sp/>type,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1218"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref><sp/>*args)<sp/></highlight></codeline>
<codeline lineno="1219"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1220"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_op_expr_node" kindref="compound">OpExprNode</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_op_expr_node" kindref="compound">OpExprNode</ref>));</highlight></codeline>
<codeline lineno="1221"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="1222"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1223"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1224"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1225"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_op_expr_node_1a69ff4baea505db8ed32f4c4027f24ac6" kindref="member">type</ref><sp/>=<sp/>type;</highlight></codeline>
<codeline lineno="1226"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_op_expr_node_1a82d6f2c460a585ee3b0a46ce00ba186f" kindref="member">args</ref><sp/>=<sp/>args;</highlight></codeline>
<codeline lineno="1227"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="1228"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1229"><highlight class="normal"></highlight></codeline>
<codeline lineno="1238"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>deleteOpExprNode(<ref refid="struct_op_expr_node" kindref="compound">OpExprNode</ref><sp/>*node)<sp/></highlight></codeline>
<codeline lineno="1239"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1240"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!node)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="1241"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(node-&gt;<ref refid="struct_op_expr_node_1a82d6f2c460a585ee3b0a46ce00ba186f" kindref="member">args</ref>);</highlight></codeline>
<codeline lineno="1242"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(node);</highlight></codeline>
<codeline lineno="1243"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1244"><highlight class="normal"></highlight></codeline>
<codeline lineno="1252"><highlight class="normal"><ref refid="struct_function_table" kindref="compound">FunctionTable</ref><sp/>*createFunctionTable(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="1253"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1254"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_function_table" kindref="compound">FunctionTable</ref><sp/>*p<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_function_table" kindref="compound">FunctionTable</ref>));</highlight></codeline>
<codeline lineno="1255"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!p)<sp/>{</highlight></codeline>
<codeline lineno="1256"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1257"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1258"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1259"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_function_table_1a568ae3641aaf56327da625e668c4aa51" kindref="member">num</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="1260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>p-&gt;<ref refid="struct_function_table_1a1c1544bb6db2f638619e21fc60ca2ba8" kindref="member">funcs</ref><sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1261"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="1262"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1263"><highlight class="normal"></highlight></codeline>
<codeline lineno="1278"><highlight class="normal"><ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref><sp/>*addFuncDefStmtNode(<ref refid="struct_function_table" kindref="compound">FunctionTable</ref><sp/>*table,<sp/><sp/></highlight></codeline>
<codeline lineno="1279"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref><sp/>*node)<sp/></highlight></codeline>
<codeline lineno="1280"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1281"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>newsize<sp/>=<sp/>table-&gt;<ref refid="struct_function_table_1a568ae3641aaf56327da625e668c4aa51" kindref="member">num</ref><sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="1282"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*mem<sp/>=<sp/>realloc(table-&gt;<ref refid="struct_function_table_1a1c1544bb6db2f638619e21fc60ca2ba8" kindref="member">funcs</ref>,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref><sp/>*)<sp/>*<sp/>newsize);</highlight></codeline>
<codeline lineno="1283"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!mem)<sp/>{</highlight></codeline>
<codeline lineno="1284"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;realloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1285"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1286"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>table-&gt;<ref refid="struct_function_table_1a1c1544bb6db2f638619e21fc60ca2ba8" kindref="member">funcs</ref><sp/>=<sp/>mem;</highlight></codeline>
<codeline lineno="1288"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>table-&gt;<ref refid="struct_function_table_1a1c1544bb6db2f638619e21fc60ca2ba8" kindref="member">funcs</ref>[table-&gt;<ref refid="struct_function_table_1a568ae3641aaf56327da625e668c4aa51" kindref="member">num</ref>]<sp/>=<sp/>node;</highlight></codeline>
<codeline lineno="1289"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>table-&gt;<ref refid="struct_function_table_1a568ae3641aaf56327da625e668c4aa51" kindref="member">num</ref><sp/>=<sp/>newsize;</highlight></codeline>
<codeline lineno="1290"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>node;</highlight></codeline>
<codeline lineno="1291"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1292"><highlight class="normal"></highlight></codeline>
<codeline lineno="1301"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>deleteFunctionTable(<ref refid="struct_function_table" kindref="compound">FunctionTable</ref><sp/>*table)<sp/></highlight></codeline>
<codeline lineno="1302"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1303"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!table)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="1304"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Don&apos;t<sp/>delete<sp/>the<sp/>FuncDefStmtNode<sp/>structures<sp/>because<sp/>they<sp/>will<sp/>be</highlight></codeline>
<codeline lineno="1305"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>deleted<sp/>by<sp/>deleteMainNode.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1306"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(table-&gt;<ref refid="struct_function_table_1a1c1544bb6db2f638619e21fc60ca2ba8" kindref="member">funcs</ref>);</highlight></codeline>
<codeline lineno="1307"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(table);</highlight></codeline>
<codeline lineno="1308"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1309"><highlight class="normal"></highlight></codeline>
<codeline lineno="1320"><highlight class="normal"><ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref><sp/>*lookupFuncDefStmtNode(<ref refid="struct_function_table" kindref="compound">FunctionTable</ref><sp/>*table,<sp/></highlight></codeline>
<codeline lineno="1321"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*name)<sp/><sp/></highlight></codeline>
<codeline lineno="1322"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1323"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n;</highlight></codeline>
<codeline lineno="1324"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(n<sp/>=<sp/>0;<sp/>n<sp/>&lt;<sp/>table-&gt;<ref refid="struct_function_table_1a568ae3641aaf56327da625e668c4aa51" kindref="member">num</ref>;<sp/>n++)<sp/>{</highlight></codeline>
<codeline lineno="1325"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref><sp/>*fun<sp/>=<sp/>(table-&gt;<ref refid="struct_function_table_1a1c1544bb6db2f638619e21fc60ca2ba8" kindref="member">funcs</ref>)[n];</highlight></codeline>
<codeline lineno="1326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!strcmp(fun-&gt;<ref refid="struct_func_def_stmt_node_1ab047936127219724532e25ba6890265a" kindref="member">name</ref>-&gt;<ref refid="struct_identifier_node_1a3e2473c7676f22d1f3beebe66f0a7688" kindref="member">image</ref>,<sp/>name))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>fun;</highlight></codeline>
<codeline lineno="1327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1328"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1329"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1330"><highlight class="normal"></highlight></codeline>
<codeline lineno="1351"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>acceptToken(<ref refid="struct_token" kindref="compound">Token</ref><sp/>***tokenp,<sp/></highlight></codeline>
<codeline lineno="1352"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="tokenizer_8h_1aa520fbf142ba1e7e659590c07da31921" kindref="member">TokenType</ref><sp/>token)<sp/></highlight></codeline>
<codeline lineno="1353"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1354"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_token" kindref="compound">Token</ref><sp/>**tokens<sp/>=<sp/>*tokenp;</highlight></codeline>
<codeline lineno="1355"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((*tokens)-&gt;type<sp/>!=<sp/>token)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="1356"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokens++;</highlight></codeline>
<codeline lineno="1357"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*tokenp<sp/>=<sp/>tokens;</highlight></codeline>
<codeline lineno="1358"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="1359"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1360"><highlight class="normal"></highlight></codeline>
<codeline lineno="1377"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>peekToken(<ref refid="struct_token" kindref="compound">Token</ref><sp/>***tokenp,<sp/></highlight></codeline>
<codeline lineno="1378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="tokenizer_8h_1aa520fbf142ba1e7e659590c07da31921" kindref="member">TokenType</ref><sp/>token)<sp/></highlight></codeline>
<codeline lineno="1379"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1380"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_token" kindref="compound">Token</ref><sp/>**tokens<sp/>=<sp/>*tokenp;</highlight></codeline>
<codeline lineno="1381"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((*tokens)-&gt;type<sp/>!=<sp/>token)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="1382"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="1383"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1384"><highlight class="normal"></highlight></codeline>
<codeline lineno="1402"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nextToken(<ref refid="struct_token" kindref="compound">Token</ref><sp/>***tokenp,<sp/></highlight></codeline>
<codeline lineno="1403"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="tokenizer_8h_1aa520fbf142ba1e7e659590c07da31921" kindref="member">TokenType</ref><sp/>token)<sp/></highlight></codeline>
<codeline lineno="1404"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1405"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_token" kindref="compound">Token</ref><sp/>**tokens<sp/>=<sp/>*tokenp;</highlight></codeline>
<codeline lineno="1406"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((*(tokens<sp/>+<sp/>1))-&gt;type<sp/>!=<sp/>token)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="1407"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="1408"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1409"><highlight class="normal"></highlight></codeline>
<codeline lineno="1415"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>error(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*info,<sp/></highlight></codeline>
<codeline lineno="1416"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_token" kindref="compound">Token</ref><sp/>**tokens)<sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1417"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1418"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/></highlight><highlight class="stringliteral">&quot;%s:%d:<sp/>%s<sp/>at:<sp/>%s\n&quot;</highlight><highlight class="normal">,<sp/>(*tokens)-&gt;fname,<sp/>(*tokens)-&gt;line,<sp/>info,<sp/>(*tokens)-&gt;image);</highlight></codeline>
<codeline lineno="1419"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1420"><highlight class="normal"></highlight></codeline>
<codeline lineno="1439"><highlight class="normal"><ref refid="struct_constant_node" kindref="compound">ConstantNode</ref><sp/>*parseConstantNode(<ref refid="struct_token" kindref="compound">Token</ref><sp/>***tokenp)</highlight></codeline>
<codeline lineno="1440"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1441"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_token" kindref="compound">Token</ref><sp/>**tokens<sp/>=<sp/>*tokenp;</highlight></codeline>
<codeline lineno="1442"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_constant_node" kindref="compound">ConstantNode</ref><sp/>*ret<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1443"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1444"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shiftout();</highlight></codeline>
<codeline lineno="1445"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1446"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Boolean<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1447"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(peekToken(&amp;tokens,<sp/>TT_BOOLEAN))<sp/>{</highlight></codeline>
<codeline lineno="1448"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1449"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;CT_BOOLEAN&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1450"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1451"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>createBooleanConstantNode((*tokens)-&gt;data.i);</highlight></codeline>
<codeline lineno="1452"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ret)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1453"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>acceptToken(&amp;tokens,<sp/>TT_BOOLEAN);<sp/></highlight><highlight class="comment">/*<sp/>Will<sp/>succeed,<sp/>checked<sp/>for<sp/>this<sp/>earlier<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1454"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1455"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Integer<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1456"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(peekToken(&amp;tokens,<sp/>TT_INTEGER))<sp/>{</highlight></codeline>
<codeline lineno="1457"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1458"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;CT_INTEGER&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1459"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1460"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>createIntegerConstantNode((*tokens)-&gt;data.i);</highlight></codeline>
<codeline lineno="1461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ret)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1462"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>acceptToken(&amp;tokens,<sp/>TT_INTEGER);<sp/></highlight><highlight class="comment">/*<sp/>Will<sp/>succeed,<sp/>checked<sp/>for<sp/>this<sp/>above<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1463"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1464"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Float<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1465"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(peekToken(&amp;tokens,<sp/>TT_FLOAT))<sp/>{</highlight></codeline>
<codeline lineno="1466"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1467"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;CT_FLOAT&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1468"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1469"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>createFloatConstantNode((*tokens)-&gt;data.f);</highlight></codeline>
<codeline lineno="1470"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ret)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1471"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>acceptToken(&amp;tokens,<sp/>TT_FLOAT);<sp/></highlight><highlight class="comment">/*<sp/>Will<sp/>succeed,<sp/>checked<sp/>for<sp/>this<sp/>above<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1472"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1473"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>String<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1474"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(peekToken(&amp;tokens,<sp/>TT_STRING))<sp/>{</highlight></codeline>
<codeline lineno="1475"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>len<sp/>=<sp/>strlen((*tokens)-&gt;image);</highlight></codeline>
<codeline lineno="1476"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*data<sp/>=<sp/>malloc(</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">char</highlight><highlight class="normal">)<sp/>*<sp/>(len<sp/>-<sp/>1));</highlight></codeline>
<codeline lineno="1477"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!data)<sp/>{</highlight></codeline>
<codeline lineno="1478"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;malloc&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1479"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1480"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1481"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>strncpy(data,<sp/>(*tokens)-&gt;image<sp/>+<sp/>1,<sp/>len<sp/>-<sp/>2);</highlight></codeline>
<codeline lineno="1482"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>data[len<sp/>-<sp/>2]<sp/>=<sp/></highlight><highlight class="charliteral">&apos;\0&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="1483"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1484"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;CT_STRING&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1485"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1486"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>createStringConstantNode(data);</highlight></codeline>
<codeline lineno="1487"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ret)<sp/>{</highlight></codeline>
<codeline lineno="1488"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>free(data);</highlight></codeline>
<codeline lineno="1489"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1490"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1491"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>acceptToken(&amp;tokens,<sp/>TT_STRING);<sp/></highlight><highlight class="comment">/*<sp/>Will<sp/>succeed,<sp/>checked<sp/>for<sp/>this<sp/>above<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1492"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1493"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>constant<sp/>value&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="1494"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1495"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shiftin();</highlight></codeline>
<codeline lineno="1496"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1497"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*tokenp<sp/>=<sp/>tokens;</highlight></codeline>
<codeline lineno="1498"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ret;</highlight></codeline>
<codeline lineno="1499"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1500"><highlight class="normal"></highlight></codeline>
<codeline lineno="1519"><highlight class="normal"><ref refid="struct_type_node" kindref="compound">TypeNode</ref><sp/>*parseTypeNode(<ref refid="struct_token" kindref="compound">Token</ref><sp/>***tokenp)<sp/></highlight></codeline>
<codeline lineno="1520"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1521"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_token" kindref="compound">Token</ref><sp/>**tokens<sp/>=<sp/>*tokenp;</highlight></codeline>
<codeline lineno="1522"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_type_node" kindref="compound">TypeNode</ref><sp/>*ret<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1523"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1524"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shiftout();</highlight></codeline>
<codeline lineno="1525"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1526"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Nil<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_NOOB))<sp/>{</highlight></codeline>
<codeline lineno="1528"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1529"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;CT_NIL&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1530"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1531"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>createTypeNode(CT_NIL);</highlight></codeline>
<codeline lineno="1532"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ret)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1533"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1534"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Boolean<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1535"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_TROOF))<sp/>{</highlight></codeline>
<codeline lineno="1536"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1537"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;CT_BOOLEAN&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1538"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1539"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>createTypeNode(CT_BOOLEAN);</highlight></codeline>
<codeline lineno="1540"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ret)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1541"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1542"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Integer<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1543"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_NUMBR))<sp/>{</highlight></codeline>
<codeline lineno="1544"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1545"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;CT_INTEGER&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1546"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1547"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>createTypeNode(CT_INTEGER);</highlight></codeline>
<codeline lineno="1548"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ret)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1549"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1550"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Float<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1551"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_NUMBAR))<sp/>{</highlight></codeline>
<codeline lineno="1552"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1553"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;CT_FLOAT&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1554"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1555"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>createTypeNode(CT_FLOAT);</highlight></codeline>
<codeline lineno="1556"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ret)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1557"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1558"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>String<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1559"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_YARN))<sp/>{</highlight></codeline>
<codeline lineno="1560"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1561"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;CT_STRING&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1562"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1563"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>createTypeNode(CT_STRING);</highlight></codeline>
<codeline lineno="1564"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ret)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1565"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1566"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>type&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="1567"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1568"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shiftin();</highlight></codeline>
<codeline lineno="1569"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1570"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*tokenp<sp/>=<sp/>tokens;</highlight></codeline>
<codeline lineno="1571"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ret;</highlight></codeline>
<codeline lineno="1572"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1573"><highlight class="normal"></highlight></codeline>
<codeline lineno="1592"><highlight class="normal"><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*parseIdentifierNode(<ref refid="struct_token" kindref="compound">Token</ref><sp/>***tokenp)<sp/></highlight></codeline>
<codeline lineno="1593"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1594"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_token" kindref="compound">Token</ref><sp/>**tokens<sp/>=<sp/>*tokenp;</highlight></codeline>
<codeline lineno="1595"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*ret<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1596"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1597"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shiftout();</highlight></codeline>
<codeline lineno="1598"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1599"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(peekToken(&amp;tokens,<sp/>TT_IDENTIFIER))<sp/>{</highlight></codeline>
<codeline lineno="1600"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1601"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;IDENTIFIER&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1602"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1603"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>createIdentifierNode((*tokens)-&gt;image,<sp/>(*tokens)-&gt;fname,<sp/>(*tokens)-&gt;line);</highlight></codeline>
<codeline lineno="1604"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ret)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1605"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>acceptToken(&amp;tokens,<sp/>TT_IDENTIFIER);<sp/></highlight><highlight class="comment">/*<sp/>Will<sp/>succeed,<sp/>checked<sp/>for<sp/>this<sp/>above<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1606"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1607"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>identifier&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="1608"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1609"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shiftin();</highlight></codeline>
<codeline lineno="1610"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1611"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*tokenp<sp/>=<sp/>tokens;</highlight></codeline>
<codeline lineno="1612"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ret;</highlight></codeline>
<codeline lineno="1613"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1614"><highlight class="normal"></highlight></codeline>
<codeline lineno="1633"><highlight class="normal"><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*parseExprNode(<ref refid="struct_token" kindref="compound">Token</ref><sp/>***tokenp,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1634"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_function_table" kindref="compound">FunctionTable</ref><sp/>*functab)<sp/></highlight></codeline>
<codeline lineno="1635"><highlight class="normal">{</highlight></codeline>
<codeline lineno="1636"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_token" kindref="compound">Token</ref><sp/>**tokens<sp/>=<sp/>*tokenp;</highlight></codeline>
<codeline lineno="1637"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*ret<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1638"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1639"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shiftout();</highlight></codeline>
<codeline lineno="1640"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1641"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Cast<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1642"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_MAEK))<sp/>{</highlight></codeline>
<codeline lineno="1643"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*target<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1644"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_type_node" kindref="compound">TypeNode</ref><sp/>*newtype<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1645"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_cast_expr_node" kindref="compound">CastExprNode</ref><sp/>*expr<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1646"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1647"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ET_CAST&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1648"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1649"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>target<sp/>=<sp/>parseExprNode(&amp;tokens,<sp/>functab);</highlight></codeline>
<codeline lineno="1650"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!target)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1651"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>acceptToken(&amp;tokens,<sp/>TT_A);</highlight></codeline>
<codeline lineno="1652"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>newtype<sp/>=<sp/>parseTypeNode(&amp;tokens);</highlight></codeline>
<codeline lineno="1653"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!newtype)<sp/>{</highlight></codeline>
<codeline lineno="1654"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(target);</highlight></codeline>
<codeline lineno="1655"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1656"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1657"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>expr<sp/>=<sp/>createCastExprNode(target,<sp/>newtype);</highlight></codeline>
<codeline lineno="1658"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!expr)<sp/>{</highlight></codeline>
<codeline lineno="1659"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(target);</highlight></codeline>
<codeline lineno="1660"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteTypeNode(newtype);</highlight></codeline>
<codeline lineno="1661"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1662"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1663"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>createExprNode(ET_CAST,<sp/>expr);</highlight></codeline>
<codeline lineno="1664"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ret)<sp/>{</highlight></codeline>
<codeline lineno="1665"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(target);</highlight></codeline>
<codeline lineno="1666"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteTypeNode(newtype);</highlight></codeline>
<codeline lineno="1667"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteCastExprNode(expr);</highlight></codeline>
<codeline lineno="1668"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1669"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1670"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1671"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Implicit<sp/>variable<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1672"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_IT))<sp/>{</highlight></codeline>
<codeline lineno="1673"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>createExprNode(ET_IMPVAR,<sp/>NULL);</highlight></codeline>
<codeline lineno="1674"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ret)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1675"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1676"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Constant<sp/>value<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1677"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(peekToken(&amp;tokens,<sp/>TT_BOOLEAN)</highlight></codeline>
<codeline lineno="1678"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/>peekToken(&amp;tokens,<sp/>TT_INTEGER)</highlight></codeline>
<codeline lineno="1679"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/>peekToken(&amp;tokens,<sp/>TT_FLOAT)</highlight></codeline>
<codeline lineno="1680"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/>peekToken(&amp;tokens,<sp/>TT_STRING))<sp/>{</highlight></codeline>
<codeline lineno="1681"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_constant_node" kindref="compound">ConstantNode</ref><sp/>*node<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1682"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1683"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ET_CONSTANT&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1684"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1685"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node<sp/>=<sp/>parseConstantNode(&amp;tokens);</highlight></codeline>
<codeline lineno="1686"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!node)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1687"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>createExprNode(ET_CONSTANT,<sp/>node);</highlight></codeline>
<codeline lineno="1688"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ret)<sp/>{</highlight></codeline>
<codeline lineno="1689"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteConstantNode(node);</highlight></codeline>
<codeline lineno="1690"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1691"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1692"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1693"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Note<sp/>that<sp/>identifiers<sp/>may<sp/>refer<sp/>to<sp/>function<sp/>calls<sp/>and<sp/>if<sp/>so,<sp/>must</highlight></codeline>
<codeline lineno="1694"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>contain<sp/>an<sp/>appropriate<sp/>number<sp/>of<sp/>arguments.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1695"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(peekToken(&amp;tokens,<sp/>TT_IDENTIFIER))<sp/>{</highlight></codeline>
<codeline lineno="1696"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref><sp/>*fun<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1697"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Function<sp/>Call<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1698"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((fun<sp/>=<sp/>lookupFuncDefStmtNode(functab,<sp/>(*tokens)-&gt;image)))<sp/>{</highlight></codeline>
<codeline lineno="1699"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_func_call_expr_node" kindref="compound">FuncCallExprNode</ref><sp/>*node<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1700"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref><sp/>*args<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1701"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n;</highlight></codeline>
<codeline lineno="1702"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>acceptToken(&amp;tokens,<sp/>TT_IDENTIFIER);<sp/></highlight><highlight class="comment">/*<sp/>Will<sp/>succeed,<sp/>checked<sp/>for<sp/>this<sp/>above<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1703"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1704"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ET_FUNCCALL&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1705"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1706"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>args<sp/>=<sp/>createExprNodeList();</highlight></codeline>
<codeline lineno="1707"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(n<sp/>=<sp/>0;<sp/>n<sp/>&lt;<sp/>fun-&gt;<ref refid="struct_func_def_stmt_node_1a2a9f4d580b7252e5576873d2252a187a" kindref="member">args</ref>-&gt;<ref refid="struct_identifier_node_list_1a7ee19db1c4e05eafe5df277542e01dd1" kindref="member">num</ref>;<sp/>n++)<sp/>{</highlight></codeline>
<codeline lineno="1708"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*arg<sp/>=<sp/>parseExprNode(&amp;tokens,<sp/>functab);</highlight></codeline>
<codeline lineno="1709"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!arg)<sp/>{</highlight></codeline>
<codeline lineno="1710"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="1711"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1712"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1713"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>addExprNode(args,<sp/>arg);</highlight></codeline>
<codeline lineno="1714"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1715"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node<sp/>=<sp/>createFuncCallExprNode(fun,<sp/>args);</highlight></codeline>
<codeline lineno="1716"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!node)<sp/>{</highlight></codeline>
<codeline lineno="1717"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="1718"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1719"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1720"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>createExprNode(ET_FUNCCALL,<sp/>node);</highlight></codeline>
<codeline lineno="1721"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ret)<sp/>{</highlight></codeline>
<codeline lineno="1722"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="1723"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteFuncCallExprNode(node);</highlight></codeline>
<codeline lineno="1724"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1725"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1726"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1727"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Identifier<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1728"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1729"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*node<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1730"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1731"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ET_IDENTIFIER&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1732"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1733"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>node<sp/>=<sp/>parseIdentifierNode(&amp;tokens);</highlight></codeline>
<codeline lineno="1734"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!node)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1735"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>createExprNode(ET_IDENTIFIER,<sp/>node);</highlight></codeline>
<codeline lineno="1736"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ret)<sp/>{</highlight></codeline>
<codeline lineno="1737"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(node);</highlight></codeline>
<codeline lineno="1738"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1739"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1740"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1741"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1742"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Binary<sp/>operations<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1743"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(peekToken(&amp;tokens,<sp/>TT_SUMOF)</highlight></codeline>
<codeline lineno="1744"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/>peekToken(&amp;tokens,<sp/>TT_DIFFOF)</highlight></codeline>
<codeline lineno="1745"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/>peekToken(&amp;tokens,<sp/>TT_PRODUKTOF)</highlight></codeline>
<codeline lineno="1746"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/>peekToken(&amp;tokens,<sp/>TT_QUOSHUNTOF)</highlight></codeline>
<codeline lineno="1747"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/>peekToken(&amp;tokens,<sp/>TT_MODOF)</highlight></codeline>
<codeline lineno="1748"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/>peekToken(&amp;tokens,<sp/>TT_BIGGROF)</highlight></codeline>
<codeline lineno="1749"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/>peekToken(&amp;tokens,<sp/>TT_SMALLROF)</highlight></codeline>
<codeline lineno="1750"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/>peekToken(&amp;tokens,<sp/>TT_BOTHOF)</highlight></codeline>
<codeline lineno="1751"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/>peekToken(&amp;tokens,<sp/>TT_EITHEROF)</highlight></codeline>
<codeline lineno="1752"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/>peekToken(&amp;tokens,<sp/>TT_WONOF)</highlight></codeline>
<codeline lineno="1753"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/>peekToken(&amp;tokens,<sp/>TT_BOTHSAEM)</highlight></codeline>
<codeline lineno="1754"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/>peekToken(&amp;tokens,<sp/>TT_DIFFRINT))<sp/>{</highlight></codeline>
<codeline lineno="1755"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref><sp/>*args<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1756"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*arg<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1757"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_op_expr_node" kindref="compound">OpExprNode</ref><sp/>*op<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1758"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>OpType<sp/>type;</highlight></codeline>
<codeline lineno="1759"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_SUMOF))<sp/>{</highlight></codeline>
<codeline lineno="1760"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>type<sp/>=<sp/>OP_ADD;</highlight></codeline>
<codeline lineno="1761"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1762"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ET_OP<sp/>(OP_ADD)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1763"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1764"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1765"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(acceptToken(&amp;tokens,<sp/>TT_DIFFOF))<sp/>{</highlight></codeline>
<codeline lineno="1766"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>type<sp/>=<sp/>OP_SUB;</highlight></codeline>
<codeline lineno="1767"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1768"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ET_OP<sp/>(OP_SUB)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1769"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1770"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1771"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(acceptToken(&amp;tokens,<sp/>TT_PRODUKTOF))<sp/>{</highlight></codeline>
<codeline lineno="1772"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>type<sp/>=<sp/>OP_MULT;</highlight></codeline>
<codeline lineno="1773"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1774"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ET_OP<sp/>(OP_MULT)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1775"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1776"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1777"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(acceptToken(&amp;tokens,<sp/>TT_QUOSHUNTOF))<sp/>{</highlight></codeline>
<codeline lineno="1778"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>type<sp/>=<sp/>OP_DIV;</highlight></codeline>
<codeline lineno="1779"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1780"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ET_OP<sp/>(OP_DIV)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1781"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1782"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1783"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(acceptToken(&amp;tokens,<sp/>TT_MODOF))<sp/>{</highlight></codeline>
<codeline lineno="1784"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>type<sp/>=<sp/>OP_MOD;</highlight></codeline>
<codeline lineno="1785"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1786"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ET_OP<sp/>(OP_MOD)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1787"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1788"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1789"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(acceptToken(&amp;tokens,<sp/>TT_BIGGROF))<sp/>{</highlight></codeline>
<codeline lineno="1790"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>type<sp/>=<sp/>OP_MAX;</highlight></codeline>
<codeline lineno="1791"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1792"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ET_OP<sp/>(OP_MAX)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1793"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1794"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1795"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(acceptToken(&amp;tokens,<sp/>TT_SMALLROF))<sp/>{</highlight></codeline>
<codeline lineno="1796"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>type<sp/>=<sp/>OP_MIN;</highlight></codeline>
<codeline lineno="1797"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1798"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ET_OP<sp/>(OP_MIN)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1799"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1800"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1801"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(acceptToken(&amp;tokens,<sp/>TT_BOTHOF))<sp/>{</highlight></codeline>
<codeline lineno="1802"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>type<sp/>=<sp/>OP_AND;</highlight></codeline>
<codeline lineno="1803"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1804"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ET_OP<sp/>(OP_AND)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1805"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1806"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1807"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(acceptToken(&amp;tokens,<sp/>TT_EITHEROF))<sp/>{</highlight></codeline>
<codeline lineno="1808"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>type<sp/>=<sp/>OP_OR;</highlight></codeline>
<codeline lineno="1809"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1810"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ET_OP<sp/>(OP_OR)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1811"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1812"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1813"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(acceptToken(&amp;tokens,<sp/>TT_WONOF))<sp/>{</highlight></codeline>
<codeline lineno="1814"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>type<sp/>=<sp/>OP_XOR;</highlight></codeline>
<codeline lineno="1815"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1816"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ET_OP<sp/>(OP_XOR)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1817"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1818"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1819"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(acceptToken(&amp;tokens,<sp/>TT_BOTHSAEM))<sp/>{</highlight></codeline>
<codeline lineno="1820"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>type<sp/>=<sp/>OP_EQ;</highlight></codeline>
<codeline lineno="1821"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1822"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ET_OP<sp/>(OP_EQ)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1823"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1824"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1825"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(acceptToken(&amp;tokens,<sp/>TT_DIFFRINT))<sp/>{</highlight></codeline>
<codeline lineno="1826"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>type<sp/>=<sp/>OP_NEQ;</highlight></codeline>
<codeline lineno="1827"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1828"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ET_OP<sp/>(OP_NEQ)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1829"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1830"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1831"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1832"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;invalid<sp/>binary<sp/>operator&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="1833"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1834"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1835"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>args<sp/>=<sp/>createExprNodeList();</highlight></codeline>
<codeline lineno="1836"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!args)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1837"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>arg<sp/>=<sp/>parseExprNode(&amp;tokens,<sp/>functab);</highlight></codeline>
<codeline lineno="1838"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!arg)<sp/>{</highlight></codeline>
<codeline lineno="1839"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="1840"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1841"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1842"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!addExprNode(args,<sp/>arg))<sp/>{</highlight></codeline>
<codeline lineno="1843"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(arg);</highlight></codeline>
<codeline lineno="1844"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="1845"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1846"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1847"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>acceptToken(&amp;tokens,<sp/>TT_AN);</highlight></codeline>
<codeline lineno="1848"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>arg<sp/>=<sp/>parseExprNode(&amp;tokens,<sp/>functab);</highlight></codeline>
<codeline lineno="1849"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!arg)<sp/>{</highlight></codeline>
<codeline lineno="1850"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="1851"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1852"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1853"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!addExprNode(args,<sp/>arg))<sp/>{</highlight></codeline>
<codeline lineno="1854"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(arg);</highlight></codeline>
<codeline lineno="1855"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="1856"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1857"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1858"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>op<sp/>=<sp/>createOpExprNode(type,<sp/>args);</highlight></codeline>
<codeline lineno="1859"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!op)<sp/>{</highlight></codeline>
<codeline lineno="1860"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="1861"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1862"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1863"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>createExprNode(ET_OP,<sp/>op);</highlight></codeline>
<codeline lineno="1864"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ret)<sp/>{</highlight></codeline>
<codeline lineno="1865"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteOpExprNode(op);</highlight></codeline>
<codeline lineno="1866"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1867"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1868"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1869"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>N-ary<sp/>operations<sp/>ending<sp/>in<sp/>MKAY<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1870"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(peekToken(&amp;tokens,<sp/>TT_ALLOF)</highlight></codeline>
<codeline lineno="1871"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/>peekToken(&amp;tokens,<sp/>TT_ANYOF))<sp/>{</highlight></codeline>
<codeline lineno="1872"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref><sp/>*args<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1873"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_op_expr_node" kindref="compound">OpExprNode</ref><sp/>*op<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1874"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>OpType<sp/>type;</highlight></codeline>
<codeline lineno="1875"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_ALLOF))<sp/>{</highlight></codeline>
<codeline lineno="1876"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>type<sp/>=<sp/>OP_AND;</highlight></codeline>
<codeline lineno="1877"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1878"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ET_OP<sp/>(OP_AND)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1879"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1880"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1881"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(acceptToken(&amp;tokens,<sp/>TT_ANYOF))<sp/>{</highlight></codeline>
<codeline lineno="1882"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>type<sp/>=<sp/>OP_OR;</highlight></codeline>
<codeline lineno="1883"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1884"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ET_OP<sp/>(OP_OR)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1885"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1886"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1887"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1888"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;invalid<sp/>n-ary<sp/>operator&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="1889"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1890"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1891"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!(args<sp/>=<sp/>createExprNodeList()))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1892"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(1)<sp/>{</highlight></codeline>
<codeline lineno="1893"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*arg<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1894"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!(arg<sp/>=<sp/>parseExprNode(&amp;tokens,<sp/>functab)))<sp/>{</highlight></codeline>
<codeline lineno="1895"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="1896"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1897"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1898"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!addExprNode(args,<sp/>arg))<sp/>{</highlight></codeline>
<codeline lineno="1899"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(arg);</highlight></codeline>
<codeline lineno="1900"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="1901"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1902"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1903"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_MKAY))<sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="1904"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>acceptToken(&amp;tokens,<sp/>TT_AN);</highlight></codeline>
<codeline lineno="1905"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1906"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!(op<sp/>=<sp/>createOpExprNode(type,<sp/>args)))<sp/>{</highlight></codeline>
<codeline lineno="1907"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="1908"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1909"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1910"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!(ret<sp/>=<sp/>createExprNode(ET_OP,<sp/>op)))<sp/>{</highlight></codeline>
<codeline lineno="1911"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteOpExprNode(op);</highlight></codeline>
<codeline lineno="1912"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1913"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1914"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1915"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>N-ary<sp/>operations<sp/>not<sp/>ending<sp/>in<sp/>MKAY<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1916"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(peekToken(&amp;tokens,<sp/>TT_SMOOSH))<sp/>{</highlight></codeline>
<codeline lineno="1917"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref><sp/>*args<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1918"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_op_expr_node" kindref="compound">OpExprNode</ref><sp/>*op<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1919"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>OpType<sp/>type;</highlight></codeline>
<codeline lineno="1920"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>acceptToken(&amp;tokens,<sp/>TT_SMOOSH);</highlight></codeline>
<codeline lineno="1921"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>type<sp/>=<sp/>OP_CAT;</highlight></codeline>
<codeline lineno="1922"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1923"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ET_OP<sp/>(OP_CAT)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1924"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1925"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!(args<sp/>=<sp/>createExprNodeList()))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1926"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(1)<sp/>{</highlight></codeline>
<codeline lineno="1927"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*arg<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1928"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!(arg<sp/>=<sp/>parseExprNode(&amp;tokens,<sp/>functab)))<sp/>{</highlight></codeline>
<codeline lineno="1929"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="1930"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1931"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1932"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!addExprNode(args,<sp/>arg))<sp/>{</highlight></codeline>
<codeline lineno="1933"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(arg);</highlight></codeline>
<codeline lineno="1934"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="1935"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1936"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1937"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_MKAY)</highlight></codeline>
<codeline lineno="1938"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/>peekToken(&amp;tokens,<sp/>TT_NEWLINE))<sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="1939"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>acceptToken(&amp;tokens,<sp/>TT_AN);</highlight></codeline>
<codeline lineno="1940"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1941"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!(op<sp/>=<sp/>createOpExprNode(type,<sp/>args)))<sp/>{</highlight></codeline>
<codeline lineno="1942"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="1943"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1944"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1945"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!(ret<sp/>=<sp/>createExprNode(ET_OP,<sp/>op)))<sp/>{</highlight></codeline>
<codeline lineno="1946"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteOpExprNode(op);</highlight></codeline>
<codeline lineno="1947"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1948"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1949"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1950"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Logical<sp/>NOT<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1951"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_NOT))<sp/>{</highlight></codeline>
<codeline lineno="1952"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref><sp/>*args<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1953"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*arg<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1954"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_op_expr_node" kindref="compound">OpExprNode</ref><sp/>*op<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1955"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1956"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ET_OP<sp/>(OP_NOT)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1957"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1958"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!(args<sp/>=<sp/>createExprNodeList()))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1959"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!(arg<sp/>=<sp/>parseExprNode(&amp;tokens,<sp/>functab)))<sp/>{</highlight></codeline>
<codeline lineno="1960"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="1961"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1962"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1963"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!addExprNode(args,<sp/>arg))<sp/>{</highlight></codeline>
<codeline lineno="1964"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(arg);</highlight></codeline>
<codeline lineno="1965"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="1966"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1967"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1968"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!(op<sp/>=<sp/>createOpExprNode(OP_NOT,<sp/>args)))<sp/>{</highlight></codeline>
<codeline lineno="1969"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="1970"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1971"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1972"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!(ret<sp/>=<sp/>createExprNode(ET_OP,<sp/>op)))<sp/>{</highlight></codeline>
<codeline lineno="1973"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteOpExprNode(op);</highlight></codeline>
<codeline lineno="1974"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="1975"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1976"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1977"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>expression&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="1978"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="1979"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shiftin();</highlight></codeline>
<codeline lineno="1980"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="1981"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*tokenp<sp/>=<sp/>tokens;</highlight></codeline>
<codeline lineno="1982"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ret;</highlight></codeline>
<codeline lineno="1983"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1984"><highlight class="normal"></highlight></codeline>
<codeline lineno="2003"><highlight class="normal"><ref refid="struct_stmt_node" kindref="compound">StmtNode</ref><sp/>*parseStmtNode(<ref refid="struct_token" kindref="compound">Token</ref><sp/>***tokenp,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2004"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_function_table" kindref="compound">FunctionTable</ref><sp/>*functab)<sp/></highlight></codeline>
<codeline lineno="2005"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2006"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_token" kindref="compound">Token</ref><sp/>**tokens<sp/>=<sp/>*tokenp;</highlight></codeline>
<codeline lineno="2007"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_stmt_node" kindref="compound">StmtNode</ref><sp/>*ret<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2008"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*expr<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2009"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="2010"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shiftout();</highlight></codeline>
<codeline lineno="2011"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="2012"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Casting<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2013"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nextToken(&amp;tokens,<sp/>TT_ISNOWA))<sp/>{</highlight></codeline>
<codeline lineno="2014"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*target<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2015"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_type_node" kindref="compound">TypeNode</ref><sp/>*newtype<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2016"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_cast_stmt_node" kindref="compound">CastStmtNode</ref><sp/>*stmt<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2017"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="2018"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ST_CAST&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="2019"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="2020"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!(target<sp/>=<sp/>parseIdentifierNode(&amp;tokens)))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2021"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_ISNOWA))<sp/>{</highlight></codeline>
<codeline lineno="2022"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>IS<sp/>NOW<sp/>A&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2023"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(target);</highlight></codeline>
<codeline lineno="2024"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2025"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2026"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!(newtype<sp/>=<sp/>parseTypeNode(&amp;tokens)))<sp/>{</highlight></codeline>
<codeline lineno="2027"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(target);</highlight></codeline>
<codeline lineno="2028"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2029"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2030"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_NEWLINE))<sp/>{</highlight></codeline>
<codeline lineno="2031"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>end<sp/>of<sp/>expression&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2032"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(target);</highlight></codeline>
<codeline lineno="2033"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteTypeNode(newtype);</highlight></codeline>
<codeline lineno="2034"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2035"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2036"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!(stmt<sp/>=<sp/>createCastStmtNode(target,<sp/>newtype)))<sp/>{</highlight></codeline>
<codeline lineno="2037"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(target);</highlight></codeline>
<codeline lineno="2038"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteTypeNode(newtype);</highlight></codeline>
<codeline lineno="2039"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2040"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2041"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!(ret<sp/>=<sp/>createStmtNode(ST_CAST,<sp/>stmt)))<sp/>{</highlight></codeline>
<codeline lineno="2042"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteCastStmtNode(stmt);</highlight></codeline>
<codeline lineno="2043"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2044"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2045"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2046"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Print<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2047"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_VISIBLE))<sp/>{</highlight></codeline>
<codeline lineno="2048"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref><sp/>*args<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2049"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>nonl<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="2050"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_print_stmt_node" kindref="compound">PrintStmtNode</ref><sp/>*stmt<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2051"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="2052"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ST_PRINT&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="2053"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="2054"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!(args<sp/>=<sp/>createExprNodeList()))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2055"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="2056"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*arg<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2057"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!(arg<sp/>=<sp/>parseExprNode(&amp;tokens,<sp/>functab)))<sp/>{</highlight></codeline>
<codeline lineno="2058"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="2059"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2060"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2061"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!addExprNode(args,<sp/>arg))<sp/>{</highlight></codeline>
<codeline lineno="2062"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="2063"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(arg);</highlight></codeline>
<codeline lineno="2064"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2065"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2066"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>acceptToken(&amp;tokens,<sp/>TT_AN);</highlight></codeline>
<codeline lineno="2067"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(!peekToken(&amp;tokens,<sp/>TT_NEWLINE)<sp/>&amp;&amp;<sp/>!peekToken(&amp;tokens,<sp/>TT_BANG));</highlight></codeline>
<codeline lineno="2068"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_BANG))<sp/>nonl<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="2069"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_NEWLINE))<sp/>{</highlight></codeline>
<codeline lineno="2070"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>end<sp/>of<sp/>expression&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2071"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="2072"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2073"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2074"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!(stmt<sp/>=<sp/>createPrintStmtNode(args,<sp/>nonl)))<sp/>{</highlight></codeline>
<codeline lineno="2075"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="2076"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2077"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2078"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!(ret<sp/>=<sp/>createStmtNode(ST_PRINT,<sp/>stmt)))<sp/>{</highlight></codeline>
<codeline lineno="2079"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deletePrintStmtNode(stmt);</highlight></codeline>
<codeline lineno="2080"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2081"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2082"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2083"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Input<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2084"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_GIMMEH))<sp/>{</highlight></codeline>
<codeline lineno="2085"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*target<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2086"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_input_stmt_node" kindref="compound">InputStmtNode</ref><sp/>*stmt<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2087"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="2088"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ST_INPUT&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="2089"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="2090"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>target<sp/>=<sp/>parseIdentifierNode(&amp;tokens);</highlight></codeline>
<codeline lineno="2091"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!target)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2092"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_NEWLINE))<sp/>{</highlight></codeline>
<codeline lineno="2093"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>end<sp/>of<sp/>expression&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2094"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(target);</highlight></codeline>
<codeline lineno="2095"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2096"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2097"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stmt<sp/>=<sp/>createInputStmtNode(target);</highlight></codeline>
<codeline lineno="2098"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!stmt)<sp/>{</highlight></codeline>
<codeline lineno="2099"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(target);</highlight></codeline>
<codeline lineno="2100"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2101"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2102"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>createStmtNode(ST_INPUT,<sp/>stmt);</highlight></codeline>
<codeline lineno="2103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ret)<sp/>{</highlight></codeline>
<codeline lineno="2104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteInputStmtNode(stmt);</highlight></codeline>
<codeline lineno="2105"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2106"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2107"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2108"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Assignment<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2109"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nextToken(&amp;tokens,<sp/>TT_R))<sp/>{</highlight></codeline>
<codeline lineno="2110"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*target<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2111"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*expr<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2112"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_assignment_stmt_node" kindref="compound">AssignmentStmtNode</ref><sp/>*stmt<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2113"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="2114"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ST_ASSIGNMENT&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="2115"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="2116"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>target<sp/>=<sp/>parseIdentifierNode(&amp;tokens);</highlight></codeline>
<codeline lineno="2117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!target)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2118"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_R))<sp/>{</highlight></codeline>
<codeline lineno="2119"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>R&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2120"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(target);</highlight></codeline>
<codeline lineno="2121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>expr<sp/>=<sp/>parseExprNode(&amp;tokens,<sp/>functab);</highlight></codeline>
<codeline lineno="2124"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!expr)<sp/>{</highlight></codeline>
<codeline lineno="2125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(target);</highlight></codeline>
<codeline lineno="2126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2127"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2128"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_NEWLINE))<sp/>{</highlight></codeline>
<codeline lineno="2129"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>end<sp/>of<sp/>statement&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(target);</highlight></codeline>
<codeline lineno="2131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(expr);</highlight></codeline>
<codeline lineno="2132"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2133"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2134"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stmt<sp/>=<sp/>createAssignmentStmtNode(target,<sp/>expr);</highlight></codeline>
<codeline lineno="2135"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!stmt)<sp/>{</highlight></codeline>
<codeline lineno="2136"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(target);</highlight></codeline>
<codeline lineno="2137"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(expr);</highlight></codeline>
<codeline lineno="2138"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2139"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2140"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>createStmtNode(ST_ASSIGNMENT,<sp/>stmt);</highlight></codeline>
<codeline lineno="2141"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ret)<sp/>{</highlight></codeline>
<codeline lineno="2142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteAssignmentStmtNode(stmt);</highlight></codeline>
<codeline lineno="2143"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2144"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Variable<sp/>declaration<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nextToken(&amp;tokens,<sp/>TT_HASA))<sp/>{</highlight></codeline>
<codeline lineno="2148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*scope<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*target<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2150"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*expr<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_declaration_stmt_node" kindref="compound">DeclarationStmtNode</ref><sp/>*stmt<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2152"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="2153"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ST_DECLARATION&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="2154"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="2155"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>scope<sp/>=<sp/>parseIdentifierNode(&amp;tokens);</highlight></codeline>
<codeline lineno="2156"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!scope)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2157"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_HASA))<sp/>{</highlight></codeline>
<codeline lineno="2158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>HAS<sp/>A&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2159"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(scope);</highlight></codeline>
<codeline lineno="2160"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2161"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2162"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>target<sp/>=<sp/>parseIdentifierNode(&amp;tokens);</highlight></codeline>
<codeline lineno="2163"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!target)<sp/>{</highlight></codeline>
<codeline lineno="2164"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(scope);</highlight></codeline>
<codeline lineno="2165"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2166"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_ITZ))<sp/>{</highlight></codeline>
<codeline lineno="2168"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>expr<sp/>=<sp/>parseExprNode(&amp;tokens,<sp/>functab);</highlight></codeline>
<codeline lineno="2169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!expr)<sp/>{</highlight></codeline>
<codeline lineno="2170"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(scope);</highlight></codeline>
<codeline lineno="2171"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(target);</highlight></codeline>
<codeline lineno="2172"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2174"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_NEWLINE))<sp/>{</highlight></codeline>
<codeline lineno="2176"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>end<sp/>of<sp/>statement&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2177"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(scope);</highlight></codeline>
<codeline lineno="2178"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(target);</highlight></codeline>
<codeline lineno="2179"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(expr)<sp/>deleteExprNode(expr);</highlight></codeline>
<codeline lineno="2180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2181"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stmt<sp/>=<sp/>createDeclarationStmtNode(scope,<sp/>target,<sp/>expr);</highlight></codeline>
<codeline lineno="2183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!stmt)<sp/>{</highlight></codeline>
<codeline lineno="2184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(scope);</highlight></codeline>
<codeline lineno="2185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(target);</highlight></codeline>
<codeline lineno="2186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(expr)<sp/>deleteExprNode(expr);</highlight></codeline>
<codeline lineno="2187"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2188"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2189"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>createStmtNode(ST_DECLARATION,<sp/>stmt);<sp/></highlight></codeline>
<codeline lineno="2190"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ret)<sp/>{</highlight></codeline>
<codeline lineno="2191"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteDeclarationStmtNode(stmt);</highlight></codeline>
<codeline lineno="2192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2193"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2194"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>If/then/else<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2196"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_ORLY))<sp/>{</highlight></codeline>
<codeline lineno="2197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_block_node" kindref="compound">BlockNode</ref><sp/>*yes<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2198"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref><sp/>*guards<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_block_node_list" kindref="compound">BlockNodeList</ref><sp/>*blocks<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_block_node" kindref="compound">BlockNode</ref><sp/>*no<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_if_then_else_stmt_node" kindref="compound">IfThenElseStmtNode</ref><sp/>*stmt<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2202"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="2203"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ST_CONDITIONA&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="2204"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="2205"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_NEWLINE))<sp/>{</highlight></codeline>
<codeline lineno="2206"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>end<sp/>of<sp/>expression&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2207"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2209"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_YARLY))<sp/>{</highlight></codeline>
<codeline lineno="2210"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>YA<sp/>RLY&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2211"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2212"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2213"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_NEWLINE))<sp/>{</highlight></codeline>
<codeline lineno="2214"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>end<sp/>of<sp/>expression&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2215"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2216"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2217"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>yes<sp/>=<sp/>parseBlockNode(&amp;tokens,<sp/>functab);</highlight></codeline>
<codeline lineno="2218"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!yes)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2219"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>guards<sp/>=<sp/>createExprNodeList();</highlight></codeline>
<codeline lineno="2220"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!guards)<sp/>{</highlight></codeline>
<codeline lineno="2221"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(yes);</highlight></codeline>
<codeline lineno="2222"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2223"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2224"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>blocks<sp/>=<sp/>createBlockNodeList();</highlight></codeline>
<codeline lineno="2225"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!blocks)<sp/>{</highlight></codeline>
<codeline lineno="2226"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(yes);</highlight></codeline>
<codeline lineno="2227"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(guards);</highlight></codeline>
<codeline lineno="2228"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2229"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2230"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_MEBBE))<sp/>{</highlight></codeline>
<codeline lineno="2231"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*guard<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2232"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_block_node" kindref="compound">BlockNode</ref><sp/>*block<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2233"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>guard<sp/>=<sp/>parseExprNode(&amp;tokens,<sp/>functab);</highlight></codeline>
<codeline lineno="2234"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!guard)<sp/>{</highlight></codeline>
<codeline lineno="2235"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(yes);</highlight></codeline>
<codeline lineno="2236"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(guards);</highlight></codeline>
<codeline lineno="2237"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNodeList(blocks);</highlight></codeline>
<codeline lineno="2238"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2239"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2240"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!addExprNode(guards,<sp/>guard))<sp/>{</highlight></codeline>
<codeline lineno="2241"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(yes);</highlight></codeline>
<codeline lineno="2242"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(guards);</highlight></codeline>
<codeline lineno="2243"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNodeList(blocks);</highlight></codeline>
<codeline lineno="2244"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(guard);</highlight></codeline>
<codeline lineno="2245"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2246"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2247"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_NEWLINE))<sp/>{</highlight></codeline>
<codeline lineno="2248"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>end<sp/>of<sp/>expression&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2249"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(yes);</highlight></codeline>
<codeline lineno="2250"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(guards);</highlight></codeline>
<codeline lineno="2251"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNodeList(blocks);</highlight></codeline>
<codeline lineno="2252"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2253"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2254"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block<sp/>=<sp/>parseBlockNode(&amp;tokens,<sp/>functab);</highlight></codeline>
<codeline lineno="2255"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!block)<sp/>{</highlight></codeline>
<codeline lineno="2256"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(yes);</highlight></codeline>
<codeline lineno="2257"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(guards);</highlight></codeline>
<codeline lineno="2258"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNodeList(blocks);</highlight></codeline>
<codeline lineno="2259"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2261"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!addBlockNode(blocks,<sp/>block))<sp/>{</highlight></codeline>
<codeline lineno="2262"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(yes);</highlight></codeline>
<codeline lineno="2263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(guards);</highlight></codeline>
<codeline lineno="2264"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNodeList(blocks);</highlight></codeline>
<codeline lineno="2265"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(block);</highlight></codeline>
<codeline lineno="2266"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2267"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2268"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2269"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_NOWAI))<sp/>{</highlight></codeline>
<codeline lineno="2270"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_NEWLINE))<sp/>{</highlight></codeline>
<codeline lineno="2271"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>end<sp/>of<sp/>expression&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2272"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(yes);</highlight></codeline>
<codeline lineno="2273"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(guards);</highlight></codeline>
<codeline lineno="2274"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNodeList(blocks);</highlight></codeline>
<codeline lineno="2275"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2276"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2277"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>no<sp/>=<sp/>parseBlockNode(&amp;tokens,<sp/>functab);</highlight></codeline>
<codeline lineno="2278"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!no)<sp/>{</highlight></codeline>
<codeline lineno="2279"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(yes);</highlight></codeline>
<codeline lineno="2280"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(guards);</highlight></codeline>
<codeline lineno="2281"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNodeList(blocks);</highlight></codeline>
<codeline lineno="2282"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2283"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2284"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2285"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_OIC))<sp/>{</highlight></codeline>
<codeline lineno="2286"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>OIC&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(yes);</highlight></codeline>
<codeline lineno="2288"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(guards);</highlight></codeline>
<codeline lineno="2289"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNodeList(blocks);</highlight></codeline>
<codeline lineno="2290"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(no)<sp/>deleteBlockNode(no);</highlight></codeline>
<codeline lineno="2291"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2292"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2293"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_NEWLINE))<sp/>{</highlight></codeline>
<codeline lineno="2294"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>end<sp/>of<sp/>expression&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2295"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(yes);</highlight></codeline>
<codeline lineno="2296"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(guards);</highlight></codeline>
<codeline lineno="2297"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNodeList(blocks);</highlight></codeline>
<codeline lineno="2298"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(no)<sp/>deleteBlockNode(no);</highlight></codeline>
<codeline lineno="2299"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2300"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2301"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stmt<sp/>=<sp/>createIfThenElseStmtNode(yes,<sp/>no,<sp/>guards,<sp/>blocks);</highlight></codeline>
<codeline lineno="2302"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!stmt)<sp/>{</highlight></codeline>
<codeline lineno="2303"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(yes);</highlight></codeline>
<codeline lineno="2304"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(guards);</highlight></codeline>
<codeline lineno="2305"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNodeList(blocks);</highlight></codeline>
<codeline lineno="2306"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(no)<sp/>deleteBlockNode(no);</highlight></codeline>
<codeline lineno="2307"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2308"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2309"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>createStmtNode(ST_IFTHENELSE,<sp/>stmt);</highlight></codeline>
<codeline lineno="2310"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ret)<sp/>{</highlight></codeline>
<codeline lineno="2311"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIfThenElseStmtNode(stmt);</highlight></codeline>
<codeline lineno="2312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2313"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2314"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2315"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Switch<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2316"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_WTF))<sp/>{</highlight></codeline>
<codeline lineno="2317"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref><sp/>*guards<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2318"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_block_node_list" kindref="compound">BlockNodeList</ref><sp/>*blocks<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2319"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_block_node" kindref="compound">BlockNode</ref><sp/>*def<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2320"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_switch_stmt_node" kindref="compound">SwitchStmtNode</ref><sp/>*stmt<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2321"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="2322"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ST_SWITCH&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="2323"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="2324"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_NEWLINE))<sp/>{</highlight></codeline>
<codeline lineno="2325"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>end<sp/>of<sp/>expression&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2328"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>guards<sp/>=<sp/>createExprNodeList();</highlight></codeline>
<codeline lineno="2329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!guards)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2330"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>blocks<sp/>=<sp/>createBlockNodeList();</highlight></codeline>
<codeline lineno="2331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!blocks)<sp/>{</highlight></codeline>
<codeline lineno="2332"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(guards);</highlight></codeline>
<codeline lineno="2333"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2334"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2335"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="2336"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_constant_node" kindref="compound">ConstantNode</ref><sp/>*c<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2337"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*guard<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2338"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_block_node" kindref="compound">BlockNode</ref><sp/>*block<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2339"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>n<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="2340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_OMG))<sp/>{</highlight></codeline>
<codeline lineno="2341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>OMG&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2342"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(guards);</highlight></codeline>
<codeline lineno="2343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNodeList(blocks);</highlight></codeline>
<codeline lineno="2344"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2345"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2349"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>c<sp/>=<sp/>parseConstantNode(&amp;tokens);</highlight></codeline>
<codeline lineno="2350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!c)<sp/>{</highlight></codeline>
<codeline lineno="2351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(guards);</highlight></codeline>
<codeline lineno="2352"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNodeList(blocks);</highlight></codeline>
<codeline lineno="2353"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2354"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2355"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Check<sp/>for<sp/>string<sp/>interpolation<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2356"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(c-&gt;<ref refid="struct_constant_node_1ae0c5b58398f2ff9a476628ea34858893" kindref="member">type</ref><sp/>==<sp/>CT_STRING<sp/>&amp;&amp;<sp/>strstr(c-&gt;<ref refid="struct_constant_node_1ae546bb49962906e06a965381014ea7ae" kindref="member">data</ref>.<ref refid="union_constant_data_1aee1ab22b8dd076717f5de146f8939b46" kindref="member">s</ref>,<sp/></highlight><highlight class="stringliteral">&quot;:{&quot;</highlight><highlight class="normal">))<sp/>{</highlight></codeline>
<codeline lineno="2357"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;cannot<sp/>use<sp/>an<sp/>interpolated<sp/>string<sp/>as<sp/>an<sp/>OMG<sp/>literal&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2358"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2359"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2360"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Check<sp/>if<sp/>constant<sp/>is<sp/>unique<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2361"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(n<sp/>=<sp/>0;<sp/>n<sp/>&lt;<sp/>guards-&gt;<ref refid="struct_expr_node_list_1a60f9bbe230725287369033df733a2b04" kindref="member">num</ref>;<sp/>n++)<sp/>{</highlight></codeline>
<codeline lineno="2362"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_constant_node" kindref="compound">ConstantNode</ref><sp/>*test<sp/>=<sp/>guards-&gt;<ref refid="struct_expr_node_list_1a10ae95f2facec652ba79e0bb5c9298c1" kindref="member">exprs</ref>[n]-&gt;<ref refid="struct_expr_node_1a2c6ff3dccfa2e543a46e01763adab3a8" kindref="member">expr</ref>;</highlight></codeline>
<codeline lineno="2363"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(c-&gt;<ref refid="struct_constant_node_1ae0c5b58398f2ff9a476628ea34858893" kindref="member">type</ref><sp/>==<sp/>test-&gt;<ref refid="struct_constant_node_1ae0c5b58398f2ff9a476628ea34858893" kindref="member">type</ref>)<sp/>{</highlight></codeline>
<codeline lineno="2364"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(((c-&gt;<ref refid="struct_constant_node_1ae0c5b58398f2ff9a476628ea34858893" kindref="member">type</ref><sp/>==<sp/>CT_BOOLEAN<sp/>||<sp/>c-&gt;<ref refid="struct_constant_node_1ae0c5b58398f2ff9a476628ea34858893" kindref="member">type</ref><sp/>==<sp/>CT_INTEGER)</highlight></codeline>
<codeline lineno="2365"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;&amp;<sp/>c-&gt;<ref refid="struct_constant_node_1ae546bb49962906e06a965381014ea7ae" kindref="member">data</ref>.<ref refid="union_constant_data_1a2bd6e6fb99485a02c81794d2a3fc5a41" kindref="member">i</ref><sp/>==<sp/>test-&gt;<ref refid="struct_constant_node_1ae546bb49962906e06a965381014ea7ae" kindref="member">data</ref>.<ref refid="union_constant_data_1a2bd6e6fb99485a02c81794d2a3fc5a41" kindref="member">i</ref>)</highlight></codeline>
<codeline lineno="2366"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/>(c-&gt;<ref refid="struct_constant_node_1ae0c5b58398f2ff9a476628ea34858893" kindref="member">type</ref><sp/>==<sp/>CT_FLOAT</highlight></codeline>
<codeline lineno="2367"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;&amp;<sp/>c-&gt;<ref refid="struct_constant_node_1ae546bb49962906e06a965381014ea7ae" kindref="member">data</ref>.<ref refid="union_constant_data_1a9c3282f50d2b4fb9752bb55fed6d1ed2" kindref="member">f</ref><sp/>==<sp/>test-&gt;<ref refid="struct_constant_node_1ae546bb49962906e06a965381014ea7ae" kindref="member">data</ref>.<ref refid="union_constant_data_1a9c3282f50d2b4fb9752bb55fed6d1ed2" kindref="member">f</ref>)</highlight></codeline>
<codeline lineno="2368"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/>(c-&gt;<ref refid="struct_constant_node_1ae0c5b58398f2ff9a476628ea34858893" kindref="member">type</ref><sp/>==<sp/>CT_STRING</highlight></codeline>
<codeline lineno="2369"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;&amp;<sp/>!strcmp(c-&gt;<ref refid="struct_constant_node_1ae546bb49962906e06a965381014ea7ae" kindref="member">data</ref>.<ref refid="union_constant_data_1aee1ab22b8dd076717f5de146f8939b46" kindref="member">s</ref>,<sp/>test-&gt;<ref refid="struct_constant_node_1ae546bb49962906e06a965381014ea7ae" kindref="member">data</ref>.<ref refid="union_constant_data_1aee1ab22b8dd076717f5de146f8939b46" kindref="member">s</ref>)))<sp/>{</highlight></codeline>
<codeline lineno="2370"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(guards);</highlight></codeline>
<codeline lineno="2371"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNodeList(blocks);</highlight></codeline>
<codeline lineno="2372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteConstantNode(c);</highlight></codeline>
<codeline lineno="2373"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;duplicate<sp/>OMG<sp/>literal&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2374"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2375"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2376"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2377"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>guard<sp/>=<sp/>createExprNode(ET_CONSTANT,<sp/>c);</highlight></codeline>
<codeline lineno="2379"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!guard)<sp/>{</highlight></codeline>
<codeline lineno="2380"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(guards);</highlight></codeline>
<codeline lineno="2381"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNodeList(blocks);</highlight></codeline>
<codeline lineno="2382"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteConstantNode(c);</highlight></codeline>
<codeline lineno="2383"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2384"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2385"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!addExprNode(guards,<sp/>guard))<sp/>{</highlight></codeline>
<codeline lineno="2386"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(guards);</highlight></codeline>
<codeline lineno="2387"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNodeList(blocks);</highlight></codeline>
<codeline lineno="2388"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(guard);</highlight></codeline>
<codeline lineno="2389"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2390"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2391"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_NEWLINE))<sp/>{</highlight></codeline>
<codeline lineno="2392"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>end<sp/>of<sp/>expression&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2393"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(guards);</highlight></codeline>
<codeline lineno="2394"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNodeList(blocks);</highlight></codeline>
<codeline lineno="2395"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2396"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2397"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block<sp/>=<sp/>parseBlockNode(&amp;tokens,<sp/>functab);</highlight></codeline>
<codeline lineno="2398"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!block)<sp/>{</highlight></codeline>
<codeline lineno="2399"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(guards);</highlight></codeline>
<codeline lineno="2400"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNodeList(blocks);</highlight></codeline>
<codeline lineno="2401"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2402"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!addBlockNode(blocks,<sp/>block))<sp/>{</highlight></codeline>
<codeline lineno="2403"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(guards);</highlight></codeline>
<codeline lineno="2404"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNodeList(blocks);</highlight></codeline>
<codeline lineno="2405"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(block);</highlight></codeline>
<codeline lineno="2406"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2407"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2408"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(peekToken(&amp;tokens,<sp/>TT_OMG));</highlight></codeline>
<codeline lineno="2409"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_OMGWTF))<sp/>{</highlight></codeline>
<codeline lineno="2410"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_NEWLINE))<sp/>{</highlight></codeline>
<codeline lineno="2411"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>end<sp/>of<sp/>expression&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2412"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(guards);</highlight></codeline>
<codeline lineno="2413"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNodeList(blocks);</highlight></codeline>
<codeline lineno="2414"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2415"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2416"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>def<sp/>=<sp/>parseBlockNode(&amp;tokens,<sp/>functab);</highlight></codeline>
<codeline lineno="2417"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!def)<sp/>{</highlight></codeline>
<codeline lineno="2418"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(guards);</highlight></codeline>
<codeline lineno="2419"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNodeList(blocks);</highlight></codeline>
<codeline lineno="2420"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2421"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2422"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2423"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_OIC))<sp/>{</highlight></codeline>
<codeline lineno="2424"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>OIC&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2425"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(guards);</highlight></codeline>
<codeline lineno="2426"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNodeList(blocks);</highlight></codeline>
<codeline lineno="2427"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(def)<sp/>deleteBlockNode(def);</highlight></codeline>
<codeline lineno="2428"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2429"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2430"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_NEWLINE))<sp/>{</highlight></codeline>
<codeline lineno="2431"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>end<sp/>of<sp/>expression&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2432"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(guards);</highlight></codeline>
<codeline lineno="2433"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNodeList(blocks);</highlight></codeline>
<codeline lineno="2434"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(def)<sp/>deleteBlockNode(def);</highlight></codeline>
<codeline lineno="2435"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2436"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2437"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stmt<sp/>=<sp/>createSwitchStmtNode(guards,<sp/>blocks,<sp/>def);</highlight></codeline>
<codeline lineno="2438"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!stmt)<sp/>{</highlight></codeline>
<codeline lineno="2439"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(guards);</highlight></codeline>
<codeline lineno="2440"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNodeList(blocks);</highlight></codeline>
<codeline lineno="2441"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(def)<sp/>deleteBlockNode(def);</highlight></codeline>
<codeline lineno="2442"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2443"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2444"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>createStmtNode(ST_SWITCH,<sp/>stmt);</highlight></codeline>
<codeline lineno="2445"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ret)<sp/>{</highlight></codeline>
<codeline lineno="2446"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteSwitchStmtNode(stmt);</highlight></codeline>
<codeline lineno="2447"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2448"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2449"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Break<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2450"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_GTFO))<sp/>{</highlight></codeline>
<codeline lineno="2451"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="2452"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ST_BREAK&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="2453"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="2454"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_NEWLINE))<sp/>{</highlight></codeline>
<codeline lineno="2455"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>end<sp/>of<sp/>expression&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2456"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2457"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2458"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>createStmtNode(ST_BREAK,<sp/>NULL);</highlight></codeline>
<codeline lineno="2459"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ret)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2460"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Return<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2462"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_FOUNDYR))<sp/>{</highlight></codeline>
<codeline lineno="2463"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*value<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2464"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_return_stmt_node" kindref="compound">ReturnStmtNode</ref><sp/>*stmt<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2465"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="2466"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ST_RETURN&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="2467"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="2468"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>value<sp/>=<sp/>parseExprNode(&amp;tokens,<sp/>functab);</highlight></codeline>
<codeline lineno="2469"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!value)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2470"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_NEWLINE))<sp/>{</highlight></codeline>
<codeline lineno="2471"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>end<sp/>of<sp/>expression&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2472"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(value);</highlight></codeline>
<codeline lineno="2473"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2474"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2475"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stmt<sp/>=<sp/>createReturnStmtNode(value);</highlight></codeline>
<codeline lineno="2476"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!stmt)<sp/>{</highlight></codeline>
<codeline lineno="2477"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(value);</highlight></codeline>
<codeline lineno="2478"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2479"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2480"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>createStmtNode(ST_RETURN,<sp/>stmt);</highlight></codeline>
<codeline lineno="2481"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ret)<sp/>{</highlight></codeline>
<codeline lineno="2482"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteReturnStmtNode(stmt);</highlight></codeline>
<codeline lineno="2483"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2484"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2485"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2486"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Loop<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2487"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_IMINYR))<sp/>{</highlight></codeline>
<codeline lineno="2488"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*name1<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2489"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*var<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2490"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*update<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2491"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*guard<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2492"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_block_node" kindref="compound">BlockNode</ref><sp/>*body<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2493"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref><sp/>*def<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2494"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*name2<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2495"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_loop_stmt_node" kindref="compound">LoopStmtNode</ref><sp/>*stmt<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2496"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="2497"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ST_LOOP&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="2498"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="2499"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>name1<sp/>=<sp/>parseIdentifierNode(&amp;tokens);</highlight></codeline>
<codeline lineno="2500"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!name1)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2501"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(peekToken(&amp;tokens,<sp/>TT_UPPIN)<sp/>||<sp/>peekToken(&amp;tokens,<sp/>TT_NERFIN))<sp/>{</highlight></codeline>
<codeline lineno="2502"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>OpType<sp/>type;</highlight></codeline>
<codeline lineno="2503"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*varcopy<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2504"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*arg1<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2505"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_constant_node" kindref="compound">ConstantNode</ref><sp/>*one<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2506"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*arg2<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2507"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref><sp/>*args<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2508"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_op_expr_node" kindref="compound">OpExprNode</ref><sp/>*op<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2509"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_UPPIN))<sp/>{</highlight></codeline>
<codeline lineno="2510"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>type<sp/>=<sp/>OP_ADD;</highlight></codeline>
<codeline lineno="2511"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="2512"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shiftout();</highlight></codeline>
<codeline lineno="2513"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ET_OP<sp/>(OP_ADD)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="2514"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="2515"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2516"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_NERFIN))<sp/>{</highlight></codeline>
<codeline lineno="2517"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>type<sp/>=<sp/>OP_SUB;</highlight></codeline>
<codeline lineno="2518"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="2519"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shiftout();</highlight></codeline>
<codeline lineno="2520"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ET_OP<sp/>(OP_SUB)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="2521"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="2522"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2523"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="2524"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>UPPIN<sp/>or<sp/>NERFIN&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2525"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2526"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_YR))<sp/>{</highlight></codeline>
<codeline lineno="2528"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>YR&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2529"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2530"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2531"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2532"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>var<sp/>=<sp/>parseIdentifierNode(&amp;tokens);</highlight></codeline>
<codeline lineno="2533"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!var)<sp/>{</highlight></codeline>
<codeline lineno="2534"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2535"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2536"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2537"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="2538"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shiftout();</highlight></codeline>
<codeline lineno="2539"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ET_CONSTANT<sp/>(CT_INTEGER)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="2540"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shiftin();</highlight></codeline>
<codeline lineno="2541"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shiftin();</highlight></codeline>
<codeline lineno="2542"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="2543"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>varcopy<sp/>=<sp/>createIdentifierNode(var-&gt;<ref refid="struct_identifier_node_1a3e2473c7676f22d1f3beebe66f0a7688" kindref="member">image</ref>,<sp/>var-&gt;<ref refid="struct_identifier_node_1a3e2e04a380b98e30c1227ae747edbe18" kindref="member">fname</ref>,<sp/>var-&gt;<ref refid="struct_identifier_node_1a64ed52f14bcfabff321d105e0a54648d" kindref="member">line</ref>);</highlight></codeline>
<codeline lineno="2544"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!varcopy)<sp/>{</highlight></codeline>
<codeline lineno="2545"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2546"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(var);</highlight></codeline>
<codeline lineno="2547"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2548"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2549"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>arg1<sp/>=<sp/>createExprNode(ET_IDENTIFIER,<sp/>varcopy);</highlight></codeline>
<codeline lineno="2550"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!arg1)<sp/>{</highlight></codeline>
<codeline lineno="2551"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2552"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(var);</highlight></codeline>
<codeline lineno="2553"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(varcopy);</highlight></codeline>
<codeline lineno="2554"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2555"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2556"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>one<sp/>=<sp/>createIntegerConstantNode(1);</highlight></codeline>
<codeline lineno="2557"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!one)<sp/>{</highlight></codeline>
<codeline lineno="2558"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2559"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(var);</highlight></codeline>
<codeline lineno="2560"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(arg1);</highlight></codeline>
<codeline lineno="2561"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2562"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2563"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>arg2<sp/>=<sp/>createExprNode(ET_CONSTANT,<sp/>one);</highlight></codeline>
<codeline lineno="2564"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!arg2)<sp/>{</highlight></codeline>
<codeline lineno="2565"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2566"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(var);</highlight></codeline>
<codeline lineno="2567"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(arg1);</highlight></codeline>
<codeline lineno="2568"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteConstantNode(one);</highlight></codeline>
<codeline lineno="2569"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2570"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2571"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>args<sp/>=<sp/>createExprNodeList();</highlight></codeline>
<codeline lineno="2572"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!args)<sp/>{</highlight></codeline>
<codeline lineno="2573"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2574"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(var);</highlight></codeline>
<codeline lineno="2575"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(arg1);</highlight></codeline>
<codeline lineno="2576"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(arg2);</highlight></codeline>
<codeline lineno="2577"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2578"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2579"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!addExprNode(args,<sp/>arg1))<sp/>{</highlight></codeline>
<codeline lineno="2580"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2581"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(var);</highlight></codeline>
<codeline lineno="2582"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(arg1);</highlight></codeline>
<codeline lineno="2583"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(arg2);</highlight></codeline>
<codeline lineno="2584"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="2585"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2586"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2587"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!addExprNode(args,<sp/>arg2))<sp/>{</highlight></codeline>
<codeline lineno="2588"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2589"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(var);</highlight></codeline>
<codeline lineno="2590"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(arg2);</highlight></codeline>
<codeline lineno="2591"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="2592"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2593"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2594"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>op<sp/>=<sp/>createOpExprNode(type,<sp/>args);</highlight></codeline>
<codeline lineno="2595"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!op)<sp/>{</highlight></codeline>
<codeline lineno="2596"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2597"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(var);</highlight></codeline>
<codeline lineno="2598"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="2599"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2600"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2601"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>update<sp/>=<sp/>createExprNode(ET_OP,<sp/>op);</highlight></codeline>
<codeline lineno="2602"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!update)<sp/>{</highlight></codeline>
<codeline lineno="2603"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2604"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(var);</highlight></codeline>
<codeline lineno="2605"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteOpExprNode(op);</highlight></codeline>
<codeline lineno="2606"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2607"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2608"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2609"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((def<sp/>=<sp/>lookupFuncDefStmtNode(functab,<sp/>(*tokens)-&gt;image)))<sp/>{</highlight></codeline>
<codeline lineno="2610"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokens++;</highlight></codeline>
<codeline lineno="2611"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_YR))<sp/>{</highlight></codeline>
<codeline lineno="2612"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>YR&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2613"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2614"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2615"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2616"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Check<sp/>for<sp/>unary<sp/>function<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2617"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(def-&gt;<ref refid="struct_func_def_stmt_node_1a2a9f4d580b7252e5576873d2252a187a" kindref="member">args</ref>-&gt;<ref refid="struct_identifier_node_list_1a7ee19db1c4e05eafe5df277542e01dd1" kindref="member">num</ref><sp/>==<sp/>1)<sp/>{</highlight></codeline>
<codeline lineno="2618"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*varcopy<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2619"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*arg<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2620"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref><sp/>*args<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2621"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_func_call_expr_node" kindref="compound">FuncCallExprNode</ref><sp/>*func<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2622"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="2623"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shiftout();</highlight></codeline>
<codeline lineno="2624"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ET_FUNCCALL&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="2625"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="2626"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>var<sp/>=<sp/>parseIdentifierNode(&amp;tokens);</highlight></codeline>
<codeline lineno="2627"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!var)<sp/>{</highlight></codeline>
<codeline lineno="2628"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2629"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2630"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2631"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="2632"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shiftin();</highlight></codeline>
<codeline lineno="2633"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="2634"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>varcopy<sp/>=<sp/>createIdentifierNode(var-&gt;<ref refid="struct_identifier_node_1a3e2473c7676f22d1f3beebe66f0a7688" kindref="member">image</ref>,<sp/>var-&gt;<ref refid="struct_identifier_node_1a3e2e04a380b98e30c1227ae747edbe18" kindref="member">fname</ref>,<sp/>var-&gt;<ref refid="struct_identifier_node_1a64ed52f14bcfabff321d105e0a54648d" kindref="member">line</ref>);</highlight></codeline>
<codeline lineno="2635"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!varcopy)<sp/>{</highlight></codeline>
<codeline lineno="2636"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2637"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(var);</highlight></codeline>
<codeline lineno="2638"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2639"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2640"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>arg<sp/>=<sp/>createExprNode(ET_IDENTIFIER,<sp/>varcopy);</highlight></codeline>
<codeline lineno="2641"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!arg)<sp/>{</highlight></codeline>
<codeline lineno="2642"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2643"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(var);</highlight></codeline>
<codeline lineno="2644"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(varcopy);</highlight></codeline>
<codeline lineno="2645"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2646"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2647"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>args<sp/>=<sp/>createExprNodeList();</highlight></codeline>
<codeline lineno="2648"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!args)<sp/>{</highlight></codeline>
<codeline lineno="2649"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2650"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(var);</highlight></codeline>
<codeline lineno="2651"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(arg);</highlight></codeline>
<codeline lineno="2652"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2653"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2654"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!addExprNode(args,<sp/>arg))<sp/>{</highlight></codeline>
<codeline lineno="2655"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2656"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(var);</highlight></codeline>
<codeline lineno="2657"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(arg);</highlight></codeline>
<codeline lineno="2658"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="2659"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2660"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2661"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>func<sp/>=<sp/>createFuncCallExprNode(def,<sp/>args);</highlight></codeline>
<codeline lineno="2662"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!func)<sp/>{</highlight></codeline>
<codeline lineno="2663"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2664"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(var);</highlight></codeline>
<codeline lineno="2665"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="2666"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2667"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2668"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>update<sp/>=<sp/>createExprNode(ET_FUNCCALL,<sp/>func);</highlight></codeline>
<codeline lineno="2669"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!update)<sp/>{</highlight></codeline>
<codeline lineno="2670"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteFuncCallExprNode(func);</highlight></codeline>
<codeline lineno="2671"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2672"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2673"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2674"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="2675"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>unary<sp/>function&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2676"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2677"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2678"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2679"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2680"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(update)<sp/>{</highlight></codeline>
<codeline lineno="2681"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_WILE))<sp/>{</highlight></codeline>
<codeline lineno="2682"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>guard<sp/>=<sp/>parseExprNode(&amp;tokens,<sp/>functab);</highlight></codeline>
<codeline lineno="2683"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!guard)<sp/>{</highlight></codeline>
<codeline lineno="2684"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2685"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(update);</highlight></codeline>
<codeline lineno="2686"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2687"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2688"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2689"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_TIL))<sp/>{</highlight></codeline>
<codeline lineno="2690"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node" kindref="compound">ExprNode</ref><sp/>*arg<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2691"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref><sp/>*args<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2692"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_op_expr_node" kindref="compound">OpExprNode</ref><sp/>*op<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2693"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="2694"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shiftout();</highlight></codeline>
<codeline lineno="2695"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ET_OP<sp/>(OP_NOT)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="2696"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="2697"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>arg<sp/>=<sp/>parseExprNode(&amp;tokens,<sp/>functab);</highlight></codeline>
<codeline lineno="2698"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!arg)<sp/>{</highlight></codeline>
<codeline lineno="2699"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2700"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(update);</highlight></codeline>
<codeline lineno="2701"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2702"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2703"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>args<sp/>=<sp/>createExprNodeList();</highlight></codeline>
<codeline lineno="2704"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!args)<sp/>{</highlight></codeline>
<codeline lineno="2705"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2706"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(update);</highlight></codeline>
<codeline lineno="2707"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(arg);</highlight></codeline>
<codeline lineno="2708"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2709"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2710"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!addExprNode(args,<sp/>arg))<sp/>{</highlight></codeline>
<codeline lineno="2711"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2712"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(update);</highlight></codeline>
<codeline lineno="2713"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(arg);</highlight></codeline>
<codeline lineno="2714"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="2715"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2716"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2717"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="2718"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shiftin();</highlight></codeline>
<codeline lineno="2719"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="2720"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>op<sp/>=<sp/>createOpExprNode(OP_NOT,<sp/>args);</highlight></codeline>
<codeline lineno="2721"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!op)<sp/>{</highlight></codeline>
<codeline lineno="2722"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2723"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(update);</highlight></codeline>
<codeline lineno="2724"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNodeList(args);</highlight></codeline>
<codeline lineno="2725"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2726"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2727"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>guard<sp/>=<sp/>createExprNode(ET_OP,<sp/>op);</highlight></codeline>
<codeline lineno="2728"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!guard)<sp/>{</highlight></codeline>
<codeline lineno="2729"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2730"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(update);</highlight></codeline>
<codeline lineno="2731"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteOpExprNode(op);</highlight></codeline>
<codeline lineno="2732"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2733"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2734"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2735"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2736"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_NEWLINE))<sp/>{</highlight></codeline>
<codeline lineno="2737"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>end<sp/>of<sp/>expression&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2738"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2739"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(update)<sp/>deleteExprNode(update);</highlight></codeline>
<codeline lineno="2740"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(guard)<sp/>deleteExprNode(guard);</highlight></codeline>
<codeline lineno="2741"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2742"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2743"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>body<sp/>=<sp/>parseBlockNode(&amp;tokens,<sp/>functab);</highlight></codeline>
<codeline lineno="2744"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!body)<sp/>{</highlight></codeline>
<codeline lineno="2745"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2746"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(update)<sp/>deleteExprNode(update);</highlight></codeline>
<codeline lineno="2747"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(guard)<sp/>deleteExprNode(guard);</highlight></codeline>
<codeline lineno="2748"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2749"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2750"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_IMOUTTAYR))<sp/>{</highlight></codeline>
<codeline lineno="2751"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>IM<sp/>OUTTA<sp/>YR&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2752"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2753"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(update)<sp/>deleteExprNode(update);</highlight></codeline>
<codeline lineno="2754"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(guard)<sp/>deleteExprNode(guard);</highlight></codeline>
<codeline lineno="2755"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(body);</highlight></codeline>
<codeline lineno="2756"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2757"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2758"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>name2<sp/>=<sp/>parseIdentifierNode(&amp;tokens);</highlight></codeline>
<codeline lineno="2759"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!name2)<sp/>{</highlight></codeline>
<codeline lineno="2760"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2761"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(update)<sp/>deleteExprNode(update);</highlight></codeline>
<codeline lineno="2762"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(guard)<sp/>deleteExprNode(guard);</highlight></codeline>
<codeline lineno="2763"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(body);</highlight></codeline>
<codeline lineno="2764"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2765"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2766"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(strcmp(name1-&gt;<ref refid="struct_identifier_node_1a3e2473c7676f22d1f3beebe66f0a7688" kindref="member">image</ref>,<sp/>name2-&gt;<ref refid="struct_identifier_node_1a3e2473c7676f22d1f3beebe66f0a7688" kindref="member">image</ref>))<sp/>{</highlight></codeline>
<codeline lineno="2767"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>matching<sp/>loop<sp/>name&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2768"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2769"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(update)<sp/>deleteExprNode(update);</highlight></codeline>
<codeline lineno="2770"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(guard)<sp/>deleteExprNode(guard);</highlight></codeline>
<codeline lineno="2771"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(body);</highlight></codeline>
<codeline lineno="2772"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name2);</highlight></codeline>
<codeline lineno="2773"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2774"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2775"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name2);</highlight></codeline>
<codeline lineno="2776"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_NEWLINE))<sp/>{</highlight></codeline>
<codeline lineno="2777"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>end<sp/>of<sp/>expression&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2778"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2779"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(update)<sp/>deleteExprNode(update);</highlight></codeline>
<codeline lineno="2780"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(guard)<sp/>deleteExprNode(guard);</highlight></codeline>
<codeline lineno="2781"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(body);</highlight></codeline>
<codeline lineno="2782"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2783"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2784"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stmt<sp/>=<sp/>createLoopStmtNode(name1,<sp/>var,<sp/>guard,<sp/>update,<sp/>body);</highlight></codeline>
<codeline lineno="2785"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!stmt)<sp/>{</highlight></codeline>
<codeline lineno="2786"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name1);</highlight></codeline>
<codeline lineno="2787"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(update)<sp/>deleteExprNode(update);</highlight></codeline>
<codeline lineno="2788"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(guard)<sp/>deleteExprNode(guard);</highlight></codeline>
<codeline lineno="2789"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(body);</highlight></codeline>
<codeline lineno="2790"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2791"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2792"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>createStmtNode(ST_LOOP,<sp/>stmt);</highlight></codeline>
<codeline lineno="2793"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ret)<sp/>{</highlight></codeline>
<codeline lineno="2794"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteLoopStmtNode(stmt);</highlight></codeline>
<codeline lineno="2795"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2796"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2797"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2798"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Function<sp/>definition<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2799"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_HOWDUZ))<sp/>{</highlight></codeline>
<codeline lineno="2800"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*scope<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2801"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*name<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2802"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_block_node" kindref="compound">BlockNode</ref><sp/>*body;</highlight></codeline>
<codeline lineno="2803"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref><sp/>*proto<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2804"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="2805"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ST_FUNCDEF&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="2806"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="2807"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Skip<sp/>over<sp/>the<sp/>scope<sp/>as<sp/>it<sp/>has<sp/>already<sp/>been<sp/>parsed<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2808"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>scope<sp/>=<sp/>parseIdentifierNode(&amp;tokens);</highlight></codeline>
<codeline lineno="2809"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!scope)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2810"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(scope);</highlight></codeline>
<codeline lineno="2811"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>name<sp/>=<sp/>parseIdentifierNode(&amp;tokens);</highlight></codeline>
<codeline lineno="2812"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!name)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2813"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Lookup<sp/>function<sp/>prototype<sp/>to<sp/>update<sp/>it<sp/>after<sp/>parsing<sp/>body<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2814"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>proto<sp/>=<sp/>lookupFuncDefStmtNode(functab,<sp/>name-&gt;<ref refid="struct_identifier_node_1a3e2473c7676f22d1f3beebe66f0a7688" kindref="member">image</ref>);</highlight></codeline>
<codeline lineno="2815"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(name);</highlight></codeline>
<codeline lineno="2816"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!proto)<sp/>{</highlight></codeline>
<codeline lineno="2817"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;function<sp/>prototype<sp/>not<sp/>found&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2818"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2819"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2820"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Skip<sp/>over<sp/>the<sp/>arguments<sp/>as<sp/>they<sp/>have<sp/>already<sp/>been<sp/>parsed<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2821"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_YR))<sp/>{</highlight></codeline>
<codeline lineno="2822"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*arg<sp/>=<sp/>parseIdentifierNode(&amp;tokens);</highlight></codeline>
<codeline lineno="2823"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!arg)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2824"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(arg);</highlight></codeline>
<codeline lineno="2825"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_ANYR))<sp/>{</highlight></codeline>
<codeline lineno="2826"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>arg<sp/>=<sp/>parseIdentifierNode(&amp;tokens);</highlight></codeline>
<codeline lineno="2827"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!arg)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2828"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(arg);</highlight></codeline>
<codeline lineno="2829"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2830"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2831"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_NEWLINE))<sp/>{</highlight></codeline>
<codeline lineno="2832"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>end<sp/>of<sp/>statement&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2833"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2834"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2835"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>body<sp/>=<sp/>parseBlockNode(&amp;tokens,<sp/>functab);</highlight></codeline>
<codeline lineno="2836"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!body)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2837"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_IFUSAYSO))<sp/>{</highlight></codeline>
<codeline lineno="2838"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>IF<sp/>YOU<sp/>SAY<sp/>SO&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2839"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(body);</highlight></codeline>
<codeline lineno="2840"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2841"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2842"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_NEWLINE))<sp/>{</highlight></codeline>
<codeline lineno="2843"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>end<sp/>of<sp/>statement&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2844"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(body);</highlight></codeline>
<codeline lineno="2845"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2846"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2847"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Update<sp/>the<sp/>function<sp/>body<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2848"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>proto-&gt;<ref refid="struct_func_def_stmt_node_1a9e50b6a41f7abe43b433fe4fd714b002" kindref="member">body</ref><sp/>=<sp/>body;</highlight></codeline>
<codeline lineno="2849"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>createStmtNode(ST_FUNCDEF,<sp/>proto);</highlight></codeline>
<codeline lineno="2850"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ret)<sp/>{</highlight></codeline>
<codeline lineno="2851"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteStmtNode(ret);</highlight></codeline>
<codeline lineno="2852"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2853"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2854"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Expression<sp/>Evaluation<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2855"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((expr<sp/>=<sp/>parseExprNode(&amp;tokens,<sp/>functab)))<sp/>{</highlight></codeline>
<codeline lineno="2856"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="2857"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;ST_EXPR&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="2858"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="2859"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_NEWLINE))<sp/>{</highlight></codeline>
<codeline lineno="2860"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteExprNode(expr);</highlight></codeline>
<codeline lineno="2861"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>end<sp/>of<sp/>expression&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2862"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2863"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2864"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ret<sp/>=<sp/>createStmtNode(ST_EXPR,<sp/>expr);</highlight></codeline>
<codeline lineno="2865"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2866"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>statement&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2867"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="2868"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shiftin();</highlight></codeline>
<codeline lineno="2869"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="2870"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*tokenp<sp/>=<sp/>tokens;</highlight></codeline>
<codeline lineno="2871"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ret;</highlight></codeline>
<codeline lineno="2872"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2873"><highlight class="normal"></highlight></codeline>
<codeline lineno="2892"><highlight class="normal"><ref refid="struct_block_node" kindref="compound">BlockNode</ref><sp/>*parseBlockNode(<ref refid="struct_token" kindref="compound">Token</ref><sp/>***tokenp,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2893"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_function_table" kindref="compound">FunctionTable</ref><sp/>*functab)<sp/></highlight></codeline>
<codeline lineno="2894"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2895"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_token" kindref="compound">Token</ref><sp/>**tokens<sp/>=<sp/>*tokenp;</highlight></codeline>
<codeline lineno="2896"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_stmt_node_list" kindref="compound">StmtNodeList</ref><sp/>*stmts<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2897"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_block_node" kindref="compound">BlockNode</ref><sp/>*block<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2898"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="2899"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shiftout();</highlight></codeline>
<codeline lineno="2900"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;&gt;ET_BLOCK&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="2901"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="2902"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stmts<sp/>=<sp/>createStmtNodeList();</highlight></codeline>
<codeline lineno="2903"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!stmts)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2904"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(!peekToken(&amp;tokens,<sp/>TT_EOF)</highlight></codeline>
<codeline lineno="2905"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;&amp;<sp/>!peekToken(&amp;tokens,<sp/>TT_KTHXBYE)<sp/>&amp;&amp;<sp/>!peekToken(&amp;tokens,<sp/>TT_OIC)</highlight></codeline>
<codeline lineno="2906"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;&amp;<sp/>!peekToken(&amp;tokens,<sp/>TT_YARLY)<sp/>&amp;&amp;<sp/>!peekToken(&amp;tokens,<sp/>TT_NOWAI)</highlight></codeline>
<codeline lineno="2907"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;&amp;<sp/>!peekToken(&amp;tokens,<sp/>TT_MEBBE)<sp/>&amp;&amp;<sp/>!peekToken(&amp;tokens,<sp/>TT_OMG)</highlight></codeline>
<codeline lineno="2908"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;&amp;<sp/>!peekToken(&amp;tokens,<sp/>TT_OMGWTF)<sp/>&amp;&amp;<sp/>!peekToken(&amp;tokens,<sp/>TT_IMOUTTAYR)</highlight></codeline>
<codeline lineno="2909"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;&amp;<sp/>!peekToken(&amp;tokens,<sp/>TT_IFUSAYSO))<sp/>{</highlight></codeline>
<codeline lineno="2910"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_stmt_node" kindref="compound">StmtNode</ref><sp/>*s<sp/>=<sp/>parseStmtNode(&amp;tokens,<sp/>functab);</highlight></codeline>
<codeline lineno="2911"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!s)<sp/>{</highlight></codeline>
<codeline lineno="2912"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteStmtNodeList(stmts);</highlight></codeline>
<codeline lineno="2913"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2914"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2915"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>addStmtNode(stmts,<sp/>s);</highlight></codeline>
<codeline lineno="2916"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2917"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="2918"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>debug(</highlight><highlight class="stringliteral">&quot;&lt;ET_BLOCK&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="2919"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shiftin();</highlight></codeline>
<codeline lineno="2920"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="2921"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*tokenp<sp/>=<sp/>tokens;</highlight></codeline>
<codeline lineno="2922"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block<sp/>=<sp/>createBlockNode(stmts);</highlight></codeline>
<codeline lineno="2923"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!block)<sp/>{</highlight></codeline>
<codeline lineno="2924"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteStmtNodeList(stmts);</highlight></codeline>
<codeline lineno="2925"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2926"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2927"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>block;</highlight></codeline>
<codeline lineno="2928"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2929"><highlight class="normal"></highlight></codeline>
<codeline lineno="2947"><highlight class="normal"><ref refid="struct_main_node" kindref="compound">MainNode</ref><sp/>*parseMainNode(<ref refid="struct_token" kindref="compound">Token</ref><sp/>**tokens,<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="2948"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_function_table" kindref="compound">FunctionTable</ref><sp/>*functab)<sp/></highlight></codeline>
<codeline lineno="2949"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2950"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_HAI))<sp/>{</highlight></codeline>
<codeline lineno="2951"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_block_node" kindref="compound">BlockNode</ref><sp/>*block<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2952"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_main_node" kindref="compound">MainNode</ref><sp/>*_main<sp/>=<sp/>NULL;<sp/></highlight><highlight class="comment">/*<sp/>main<sp/>is<sp/>reserved<sp/>for<sp/>the<sp/>main<sp/>function<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2953"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="2954"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/></highlight><highlight class="stringliteral">&quot;ET_MAINBLOCK\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="2955"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="2956"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tokens++;<sp/></highlight><highlight class="comment">/*<sp/>Accept<sp/>any<sp/>version<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2957"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_NEWLINE))<sp/>{</highlight></codeline>
<codeline lineno="2958"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>end<sp/>of<sp/>statement&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2959"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2960"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2961"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block<sp/>=<sp/>parseBlockNode(&amp;tokens,<sp/>functab);</highlight></codeline>
<codeline lineno="2962"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!block)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2963"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_KTHXBYE))<sp/>{</highlight></codeline>
<codeline lineno="2964"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>KTHXBYE&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2965"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(block);</highlight></codeline>
<codeline lineno="2966"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2967"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2968"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_main<sp/>=<sp/>createMainNode(block,<sp/>functab);</highlight></codeline>
<codeline lineno="2969"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!_main)<sp/>{</highlight></codeline>
<codeline lineno="2970"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteBlockNode(block);</highlight></codeline>
<codeline lineno="2971"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2972"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2973"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>_main;</highlight></codeline>
<codeline lineno="2974"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2975"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="2976"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>HAI&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="2977"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="2978"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2979"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2980"><highlight class="normal"></highlight></codeline>
<codeline lineno="2990"><highlight class="normal"><ref refid="struct_function_table" kindref="compound">FunctionTable</ref><sp/>*setupFunctionTable(<ref refid="struct_token" kindref="compound">Token</ref><sp/>**tokens)<sp/></highlight></codeline>
<codeline lineno="2991"><highlight class="normal">{</highlight></codeline>
<codeline lineno="2992"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_function_table" kindref="compound">FunctionTable</ref><sp/>*p<sp/>=<sp/>createFunctionTable();</highlight></codeline>
<codeline lineno="2993"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="2994"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/></highlight><highlight class="stringliteral">&quot;Setting<sp/>up<sp/>function<sp/>table...\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="2995"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="2996"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(*tokens)<sp/>{</highlight></codeline>
<codeline lineno="2997"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_HOWDUZ))<sp/>{</highlight></codeline>
<codeline lineno="2998"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*scope<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="2999"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*name<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="3000"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_identifier_node_list" kindref="compound">IdentifierNodeList</ref><sp/>*args<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="3001"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref><sp/>*stmt<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="3002"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>scope<sp/>=<sp/>parseIdentifierNode(&amp;tokens);</highlight></codeline>
<codeline lineno="3003"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!scope)<sp/>{</highlight></codeline>
<codeline lineno="3004"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteFunctionTable(p);</highlight></codeline>
<codeline lineno="3005"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="3006"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3007"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>name<sp/>=<sp/>parseIdentifierNode(&amp;tokens);</highlight></codeline>
<codeline lineno="3008"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!name)<sp/>{</highlight></codeline>
<codeline lineno="3009"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteFunctionTable(p);</highlight></codeline>
<codeline lineno="3010"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(scope);</highlight></codeline>
<codeline lineno="3011"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="3012"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3013"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>args<sp/>=<sp/>createIdentifierNodeList();</highlight></codeline>
<codeline lineno="3014"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!args)<sp/>{</highlight></codeline>
<codeline lineno="3015"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteFunctionTable(p);</highlight></codeline>
<codeline lineno="3016"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(scope);</highlight></codeline>
<codeline lineno="3017"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3018"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_YR))<sp/>{</highlight></codeline>
<codeline lineno="3019"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref><sp/>*arg<sp/>=<sp/>parseIdentifierNode(&amp;tokens);</highlight></codeline>
<codeline lineno="3020"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!arg)<sp/>{</highlight></codeline>
<codeline lineno="3021"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteFunctionTable(p);</highlight></codeline>
<codeline lineno="3022"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(scope);</highlight></codeline>
<codeline lineno="3023"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNodeList(args);</highlight></codeline>
<codeline lineno="3024"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="3025"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3026"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!addIdentifierNode(args,<sp/>arg))<sp/>{</highlight></codeline>
<codeline lineno="3027"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteFunctionTable(p);</highlight></codeline>
<codeline lineno="3028"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(scope);</highlight></codeline>
<codeline lineno="3029"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNodeList(args);</highlight></codeline>
<codeline lineno="3030"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(arg);</highlight></codeline>
<codeline lineno="3031"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="3032"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3033"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(acceptToken(&amp;tokens,<sp/>TT_ANYR))<sp/>{</highlight></codeline>
<codeline lineno="3034"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>arg<sp/>=<sp/>parseIdentifierNode(&amp;tokens);</highlight></codeline>
<codeline lineno="3035"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!arg)<sp/>{</highlight></codeline>
<codeline lineno="3036"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteFunctionTable(p);</highlight></codeline>
<codeline lineno="3037"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(scope);</highlight></codeline>
<codeline lineno="3038"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNodeList(args);</highlight></codeline>
<codeline lineno="3039"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="3040"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3041"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!addIdentifierNode(args,<sp/>arg))<sp/>{</highlight></codeline>
<codeline lineno="3042"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteFunctionTable(p);</highlight></codeline>
<codeline lineno="3043"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(scope);</highlight></codeline>
<codeline lineno="3044"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNodeList(args);</highlight></codeline>
<codeline lineno="3045"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(arg);</highlight></codeline>
<codeline lineno="3046"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="3047"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3048"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3049"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3050"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!acceptToken(&amp;tokens,<sp/>TT_NEWLINE))<sp/>{</highlight></codeline>
<codeline lineno="3051"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>error(</highlight><highlight class="stringliteral">&quot;expected<sp/>end<sp/>of<sp/>statement&quot;</highlight><highlight class="normal">,<sp/>tokens);</highlight></codeline>
<codeline lineno="3052"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteFunctionTable(p);</highlight></codeline>
<codeline lineno="3053"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(scope);</highlight></codeline>
<codeline lineno="3054"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNodeList(args);</highlight></codeline>
<codeline lineno="3055"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="3056"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3057"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>stmt<sp/>=<sp/>createFuncDefStmtNode(scope,<sp/>name,<sp/>args,<sp/>NULL);</highlight></codeline>
<codeline lineno="3058"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!stmt)<sp/>{</highlight></codeline>
<codeline lineno="3059"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteFunctionTable(p);</highlight></codeline>
<codeline lineno="3060"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNode(scope);</highlight></codeline>
<codeline lineno="3061"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteIdentifierNodeList(args);</highlight></codeline>
<codeline lineno="3062"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="3063"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3064"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!addFuncDefStmtNode(p,<sp/>stmt))<sp/>{</highlight></codeline>
<codeline lineno="3065"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteFunctionTable(p);</highlight></codeline>
<codeline lineno="3066"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>deleteFuncDefStmtNode(stmt);</highlight></codeline>
<codeline lineno="3067"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="3068"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3069"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3070"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>tokens++;</highlight></codeline>
<codeline lineno="3071"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="3072"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>DEBUG</highlight></codeline>
<codeline lineno="3073"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/></highlight><highlight class="stringliteral">&quot;Done<sp/>setting<sp/>up<sp/>function<sp/>table...\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="3074"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight></codeline>
<codeline lineno="3075"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>p;</highlight></codeline>
<codeline lineno="3076"><highlight class="normal">}</highlight></codeline>
    </programlisting>
    <location file="/Users/ericgallager/uscode/tools/lci/lciframework/parser.c"/>
  </compounddef>
</doxygen>
