<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.0">
  <compounddef id="lolebnf" kind="page">
    <compoundname>lolebnf</compoundname>
    <title>The LOLCODE EBNF</title>
    <detaileddescription>
<para>Presented below is the EBNF (see <ulink url="http://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form">http://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form</ulink>) for LOLCODE that <computeroutput>lci</computeroutput> parses. Note that by this stage, the scanner has:<itemizedlist>
<listitem><para>already removed any whitespace between tokens,</para></listitem><listitem><para>added in and truncated newline tokens at logical line breaks, and</para></listitem><listitem><para>added an end-of-file (<computeroutput>$</computeroutput>) token.</para></listitem></itemizedlist>
</para><sect1 id="lolebnf_1progebnf">
<title>Program Structure</title>
<para>These production rules dictate the overall form of the program.</para><para><simplesect kind="par"><title></title><para><ref refid="struct_main_node" kindref="compound">MainNode</ref> ::= <computeroutput>TT_HAI</computeroutput> <emphasis>version</emphasis> <computeroutput>TT_NEWLINE</computeroutput> <ref refid="struct_block_node" kindref="compound">BlockNode</ref> <computeroutput>$</computeroutput> </para></simplesect>
<simplesect kind="par"><title></title><para><ref refid="struct_block_node" kindref="compound">BlockNode</ref> ::= <ref refid="struct_stmt_node" kindref="compound">StmtNode</ref> *</para></simplesect>
</para></sect1>
<sect1 id="lolebnf_1stmtebnf">
<title>Statements</title>
<para>These production rules specify some general types of parse structures.</para><para><simplesect kind="par"><title></title><para><ref refid="struct_constant_node" kindref="compound">ConstantNode</ref> ::= Boolean | Integer | Float | String</para></simplesect>
<simplesect kind="par"><title></title><para><ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> ::= Identifier</para></simplesect>
<simplesect kind="par"><title></title><para><ref refid="struct_type_node" kindref="compound">TypeNode</ref> ::= <computeroutput>TT_NOOB</computeroutput> | <computeroutput>TT_TROOF</computeroutput> | <computeroutput>TT_NUMBR</computeroutput> | <computeroutput>TT_NUMBAR</computeroutput> | <computeroutput>TT_YARN</computeroutput> </para></simplesect>
</para></sect1>
<sect1 id="lolebnf_1stmtebnf">
<title>Statements</title>
<para>These production rules specify the types of statements formed.</para><para><simplesect kind="par"><title></title><para><ref refid="struct_stmt_node" kindref="compound">StmtNode</ref> ::= <ref refid="struct_cast_stmt_node" kindref="compound">CastStmtNode</ref> | <ref refid="struct_print_stmt_node" kindref="compound">PrintStmtNode</ref> | <ref refid="struct_input_stmt_node" kindref="compound">InputStmtNode</ref> | <ref refid="struct_assignment_stmt_node" kindref="compound">AssignmentStmtNode</ref> | <ref refid="struct_declaration_stmt_node" kindref="compound">DeclarationStmtNode</ref> | <ref refid="struct_if_then_else_stmt_node" kindref="compound">IfThenElseStmtNode</ref> | <ref refid="struct_switch_stmt_node" kindref="compound">SwitchStmtNode</ref> | BreakStmt | <ref refid="struct_return_stmt_node" kindref="compound">ReturnStmtNode</ref> | <ref refid="struct_loop_stmt_node" kindref="compound">LoopStmtNode</ref> | <ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref> | ExprStmt</para></simplesect>
<simplesect kind="par"><title></title><para><ref refid="struct_cast_stmt_node" kindref="compound">CastStmtNode</ref> ::= <ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> <computeroutput>TT_ISNOWA</computeroutput> <ref refid="struct_type_node" kindref="compound">TypeNode</ref> <computeroutput>TT_NEWLINE</computeroutput> </para></simplesect>
<simplesect kind="par"><title></title><para><ref refid="struct_print_stmt_node" kindref="compound">PrintStmtNode</ref> ::= <computeroutput>TT_VISIBLE</computeroutput> <ref refid="struct_expr_node_list" kindref="compound">ExprNodeList</ref> <computeroutput></computeroutput>[ <computeroutput>TT_BANG</computeroutput> ] TT_NEWLINE</para></simplesect>
<simplesect kind="par"><title></title><para><ref refid="struct_input_stmt_node" kindref="compound">InputStmtNode</ref> ::= <computeroutput>TT_GIMMEH</computeroutput> <ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> TT_NEWLINE</para></simplesect>
<simplesect kind="par"><title></title><para><ref refid="struct_assignment_stmt_node" kindref="compound">AssignmentStmtNode</ref> ::= <ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> <computeroutput>TT_R</computeroutput> <ref refid="struct_expr_node" kindref="compound">ExprNode</ref> <computeroutput>TT_NEWLINE</computeroutput> </para></simplesect>
<simplesect kind="par"><title></title><para><ref refid="struct_declaration_stmt_node" kindref="compound">DeclarationStmtNode</ref> ::= <ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> <computeroutput>TT_HASA</computeroutput> <ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> [ Initialization ] <computeroutput>TT_NEWLINE</computeroutput> </para></simplesect>
<simplesect kind="par"><title></title><para>Initialization ::= <computeroutput>TT_ITZ</computeroutput> <ref refid="struct_expr_node" kindref="compound">ExprNode</ref></para></simplesect>
<simplesect kind="par"><title></title><para><ref refid="struct_if_then_else_stmt_node" kindref="compound">IfThenElseStmtNode</ref> ::= <computeroutput>TT_ORLY</computeroutput> <computeroutput>TT_NEWLINE</computeroutput> <computeroutput>TT_YARLY</computeroutput> <computeroutput>TT_NEWLINE</computeroutput> <ref refid="struct_block_node" kindref="compound">BlockNode</ref> ElseIf * [ Else ] <computeroutput>TT_OIC</computeroutput> <computeroutput>TT_NEWLINE</computeroutput> </para></simplesect>
<simplesect kind="par"><title></title><para>ElseIf ::= <computeroutput>TT_MEBBE</computeroutput> <ref refid="struct_expr_node" kindref="compound">ExprNode</ref> <computeroutput>TT_NEWLINE</computeroutput> <ref refid="struct_block_node" kindref="compound">BlockNode</ref></para></simplesect>
<simplesect kind="par"><title></title><para>Else ::= <computeroutput>TT_NOWAI</computeroutput> <computeroutput>TT_NEWLINE</computeroutput> <ref refid="struct_block_node" kindref="compound">BlockNode</ref></para></simplesect>
<simplesect kind="par"><title></title><para><ref refid="struct_switch_stmt_node" kindref="compound">SwitchStmtNode</ref> ::= <computeroutput>TT_WTF</computeroutput> <computeroutput>TT_NEWLINE</computeroutput> Case + [ DefaultCase ] <computeroutput>TT_OIC</computeroutput> <computeroutput>TT_NEWLINE</computeroutput> </para></simplesect>
<simplesect kind="par"><title></title><para>Case ::= <computeroutput>TT_OMG</computeroutput> <ref refid="struct_expr_node" kindref="compound">ExprNode</ref> <computeroutput>TT_NEWLINE</computeroutput> <ref refid="struct_block_node" kindref="compound">BlockNode</ref></para></simplesect>
<simplesect kind="par"><title></title><para>DefaultCase ::= <computeroutput>TT_OMGWTF</computeroutput> <computeroutput>TT_NEWLINE</computeroutput> <ref refid="struct_block_node" kindref="compound">BlockNode</ref></para></simplesect>
<simplesect kind="par"><title></title><para>BreakStmt ::= <computeroutput>TT_GTFO</computeroutput> <computeroutput>TT_NEWLINE</computeroutput> </para></simplesect>
<simplesect kind="par"><title></title><para><ref refid="struct_return_stmt_node" kindref="compound">ReturnStmtNode</ref> ::= <computeroutput>TT_FOUNDYR</computeroutput> <ref refid="struct_expr_node" kindref="compound">ExprNode</ref> <computeroutput>TT_NEWLINE</computeroutput> </para></simplesect>
<simplesect kind="par"><title></title><para><ref refid="struct_loop_stmt_node" kindref="compound">LoopStmtNode</ref> ::= <computeroutput>TT_IMINYR</computeroutput> <ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> [ LoopUpdate ] [ LoopGuard ] <computeroutput>TT_NEWLINE</computeroutput> <computeroutput>TT_IMOUTTAYR</computeroutput> <ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> <computeroutput>TT_NEWLINE</computeroutput> </para></simplesect>
<simplesect kind="par"><title></title><para>LoopUpdate ::= LoopUpdateOp <computeroutput>TT_YR</computeroutput> <ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref></para></simplesect>
<simplesect kind="par"><title></title><para>LoopUpdateOp ::= <computeroutput>TT_UPPIN</computeroutput> | <computeroutput>TT_NERFIN</computeroutput> | UnaryFunction</para></simplesect>
<simplesect kind="par"><title></title><para>UnaryFunction ::= The name of a previously defined unary function.</para></simplesect>
<simplesect kind="par"><title></title><para>LoopGuard ::= <computeroutput>TT_TIL</computeroutput> <ref refid="struct_expr_node" kindref="compound">ExprNode</ref> | <computeroutput>TT_WILE</computeroutput> <ref refid="struct_expr_node" kindref="compound">ExprNode</ref></para></simplesect>
<simplesect kind="par"><title></title><para><ref refid="struct_func_def_stmt_node" kindref="compound">FuncDefStmtNode</ref> ::= <computeroutput>TT_HOWDUZ</computeroutput> <ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> <ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> [ FunctionDefArgs ] <computeroutput>TT_NEWLINE</computeroutput> <ref refid="struct_block_node" kindref="compound">BlockNode</ref> <computeroutput>TT_IFUSAYSO</computeroutput> <computeroutput>TT_NEWLINE</computeroutput> </para></simplesect>
<simplesect kind="par"><title></title><para>FunctionDefArgs ::= <computeroutput>TT_YR</computeroutput> <ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> FunctionDefArg *</para></simplesect>
<simplesect kind="par"><title></title><para>FunctionDefArg ::= <computeroutput>TT_ANYR</computeroutput> <ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref></para></simplesect>
<simplesect kind="par"><title></title><para>ExprStmt ::= <ref refid="struct_expr_node" kindref="compound">ExprNode</ref> <computeroutput>TT_NEWLINE</computeroutput> </para></simplesect>
</para></sect1>
<sect1 id="lolebnf_1exprebnf">
<title>Expressions</title>
<para>These production rules specify the types of expressions formed.</para><para><simplesect kind="par"><title></title><para><ref refid="struct_expr_node" kindref="compound">ExprNode</ref> ::= <ref refid="struct_cast_expr_node" kindref="compound">CastExprNode</ref> | <ref refid="struct_constant_node" kindref="compound">ConstantNode</ref> | <ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref> | <ref refid="struct_func_call_expr_node" kindref="compound">FuncCallExprNode</ref> | <ref refid="struct_op_expr_node" kindref="compound">OpExprNode</ref> | ImplicitVariable</para></simplesect>
<simplesect kind="par"><title></title><para><ref refid="struct_cast_expr_node" kindref="compound">CastExprNode</ref> ::= <computeroutput>TT_MAEK</computeroutput> <ref refid="struct_expr_node" kindref="compound">ExprNode</ref> <computeroutput>TT_A</computeroutput> <ref refid="struct_type_node" kindref="compound">TypeNode</ref></para></simplesect>
<simplesect kind="par"><title></title><para><ref refid="struct_func_call_expr_node" kindref="compound">FuncCallExprNode</ref> ::= <ref refid="struct_identifier_node" kindref="compound">IdentifierNode</ref></para></simplesect>
<simplesect kind="par"><title></title><para><ref refid="struct_op_expr_node" kindref="compound">OpExprNode</ref> ::= UnaryOp | BinaryOp | NaryOp</para></simplesect>
<simplesect kind="par"><title></title><para>UnaryOp ::= UnaryOpType <ref refid="struct_expr_node" kindref="compound">ExprNode</ref></para></simplesect>
<simplesect kind="par"><title></title><para>UnaryOpType ::= <computeroutput>TT_NOT</computeroutput> </para></simplesect>
<simplesect kind="par"><title></title><para>BinaryOp ::= BinaryOpType <ref refid="struct_expr_node" kindref="compound">ExprNode</ref> [ <computeroutput>TT_AN</computeroutput> ] <ref refid="struct_expr_node" kindref="compound">ExprNode</ref></para></simplesect>
<simplesect kind="par"><title></title><para>BinaryOpType ::= <computeroutput>TT_SUMOF</computeroutput> | <computeroutput>TT_DIFFOF</computeroutput> | <computeroutput>TT_PRODUKTOF</computeroutput> | <computeroutput>TT_QUOSHUNTOF</computeroutput> | <computeroutput>TT_MODOF</computeroutput> | <computeroutput>BIGGROF</computeroutput> | <computeroutput>SMALLROF</computeroutput> | <computeroutput>TT_BOTHOF</computeroutput> | <computeroutput>TT_EITHEROF</computeroutput> | <computeroutput>TT_WONOF</computeroutput> </para></simplesect>
<simplesect kind="par"><title></title><para>NaryOp ::= NaryOpType NaryOpArgs <computeroutput>TT_MKAY</computeroutput> </para></simplesect>
<simplesect kind="par"><title></title><para>NaryOpType ::= <computeroutput>TT_ALLOF</computeroutput> | <computeroutput>TT_ANYOF</computeroutput> </para></simplesect>
<simplesect kind="par"><title></title><para>NaryOpArgs ::= <ref refid="struct_expr_node" kindref="compound">ExprNode</ref> NaryOpArg +</para></simplesect>
<simplesect kind="par"><title></title><para>NaryOpArg ::= [ <computeroutput>TT_AN</computeroutput> ] <ref refid="struct_expr_node" kindref="compound">ExprNode</ref></para></simplesect>
<simplesect kind="par"><title></title><para>ImplicitVariable ::= <computeroutput>TT_IT</computeroutput> </para></simplesect>
</para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
