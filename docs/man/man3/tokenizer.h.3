.TH "tools/lci/lciframework/tokenizer.h" 3 "Tue May 8 2012" "ResKnife" \" -*- nroff -*-
.ad l
.nh
.SH NAME
tools/lci/lciframework/tokenizer.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stdlib\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include 'lexer\&.h'\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "union \fBTokenData\fP"
.br
.ti -1c
.RI "struct \fBToken\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBTokenType\fP { \fBTT_INTEGER\fP, \fBTT_FLOAT\fP, \fBTT_STRING\fP, \fBTT_IDENTIFIER\fP, \fBTT_BOOLEAN\fP, \fBTT_IT\fP, \fBTT_NOOB\fP, \fBTT_NUMBR\fP, \fBTT_NUMBAR\fP, \fBTT_TROOF\fP, \fBTT_YARN\fP, \fBTT_EOF\fP, \fBTT_NEWLINE\fP, \fBTT_HAI\fP, \fBTT_KTHXBYE\fP, \fBTT_HASA\fP, \fBTT_ITZ\fP, \fBTT_R\fP, \fBTT_ANYR\fP, \fBTT_AN\fP, \fBTT_SUMOF\fP, \fBTT_DIFFOF\fP, \fBTT_PRODUKTOF\fP, \fBTT_QUOSHUNTOF\fP, \fBTT_MODOF\fP, \fBTT_BIGGROF\fP, \fBTT_SMALLROF\fP, \fBTT_BOTHOF\fP, \fBTT_EITHEROF\fP, \fBTT_WONOF\fP, \fBTT_NOT\fP, \fBTT_MKAY\fP, \fBTT_ALLOF\fP, \fBTT_ANYOF\fP, \fBTT_BOTHSAEM\fP, \fBTT_DIFFRINT\fP, \fBTT_MAEK\fP, \fBTT_A\fP, \fBTT_ISNOWA\fP, \fBTT_VISIBLE\fP, \fBTT_SMOOSH\fP, \fBTT_BANG\fP, \fBTT_GIMMEH\fP, \fBTT_ORLY\fP, \fBTT_YARLY\fP, \fBTT_MEBBE\fP, \fBTT_NOWAI\fP, \fBTT_OIC\fP, \fBTT_WTF\fP, \fBTT_OMG\fP, \fBTT_OMGWTF\fP, \fBTT_GTFO\fP, \fBTT_IMINYR\fP, \fBTT_UPPIN\fP, \fBTT_NERFIN\fP, \fBTT_YR\fP, \fBTT_TIL\fP, \fBTT_WILE\fP, \fBTT_IMOUTTAYR\fP, \fBTT_HOWDUZ\fP, \fBTT_IFUSAYSO\fP, \fBTT_FOUNDYR\fP, \fBTT_ENDOFTOKENS\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBisInteger\fP (const char *)"
.br
.ti -1c
.RI "int \fBisFloat\fP (const char *)"
.br
.ti -1c
.RI "int \fBisString\fP (const char *)"
.br
.ti -1c
.RI "int \fBisIdentifier\fP (const char *)"
.br
.ti -1c
.RI "\fBToken\fP * \fBcreateToken\fP (\fBTokenType\fP, const char *, const char *, unsigned int)"
.br
.ti -1c
.RI "void \fBdeleteToken\fP (\fBToken\fP *)"
.br
.ti -1c
.RI "\fBToken\fP * \fBaddToken\fP (\fBToken\fP ***, unsigned int *, \fBToken\fP *)"
.br
.ti -1c
.RI "void \fBdeleteTokens\fP (\fBToken\fP **)"
.br
.ti -1c
.RI "unsigned int \fBacceptLexemes\fP (\fBLexemeList\fP *, unsigned int, const char *)"
.br
.ti -1c
.RI "\fBToken\fP * \fBisKeyword\fP (\fBLexemeList\fP *, unsigned int *)"
.br
.ti -1c
.RI "\fBToken\fP ** \fBtokenizeLexemes\fP (\fBLexemeList\fP *)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Structures and functions for grouping lexemes into tokens\&. The tokenizer reads through an array of lexemes (generated by the lexer) and groups them into tokens based on their structure\&. In addition, some lexemes with semantic meaning (such as integers, floats, strings, and booleans) will have their values extracted and stored\&.
.PP
\fBAuthor:\fP
.RS 4
Justin J\&. Meza
.RE
.PP
\fBDate:\fP
.RS 4
2010 
.RE
.PP

.PP
Definition in file \fBtokenizer\&.h\fP\&.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBTokenType\fP"
Denotes the type of token present\&. All of the token type names are self-explainatory and correspond to either the semantic type of token data (in the case of TT_INTEGER, TT_FLOAT, TT_STRING, or TT_IDENTIFIER) or the lexemes which make up the particular token\&. 
.PP
Definition at line 28 of file tokenizer\&.h\&.
.SH "Function Documentation"
.PP 
.SS "unsigned int \fBacceptLexemes\fP (\fBLexemeList\fP *lexemes, unsigned intstart, const char *match)"
Tries to match a sequence of lexemes\&. Scans through \fIlexemes\fP starting at \fIstart\fP and tries to match space-delimited lexemes from \fImatch\fP\&.
.PP
\fBPrecondition:\fP
.RS 4
\fIlexemes\fP was created by \fBscanBuffer(const char *, unsigned int, const char *)\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
The number of lexemes matched\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlexemes\fP A pointer to a \fBLexemeList\fP structure to match lexemes from\&. 
.br
\fIstart\fP The position within \fIlexemes\fP to start matching at\&. 
.br
\fImatch\fP A pointer to a character array describing the sequence of lexemes to match\&. 
.RE
.PP

.PP
Definition at line 195 of file tokenizer\&.c\&.
.SS "\fBToken\fP* \fBaddToken\fP (\fBToken\fP ***list, unsigned int *num, \fBToken\fP *token)"
Adds a \fBToken\fP to an array of \fBToken\fP structures\&.
.PP
\fBNote:\fP
.RS 4
\fIlist\fP may be NULL in which case a new list is created\&.
.RE
.PP
\fBPrecondition:\fP
.RS 4
\fInum\fP is the number of elements in \fIlist\fP\&.
.RE
.PP
\fBPostcondition:\fP
.RS 4
\fItoken\fP will be added on to the end of \fIlist\fP and the value at \fInum\fP will be updated accordingly\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A pointer to the added \fBToken\fP structure (will be the same as \fItoken\fP)\&.
.RE
.PP
\fBReturn values:\fP
.RS 4
\fINULL\fP realloc was unable to allocate memory\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBdeleteTokens(Token **)\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlist\fP A pointer to a pointer to an array of \fBToken\fP structures to add the new \fBToken\fP onto\&. 
.br
\fInum\fP A pointer to the number of elements in \fIlist\fP\&. 
.br
\fItoken\fP A pointer to the \fBToken\fP structure to add to \fIlist\fP\&. 
.RE
.PP

.PP
Definition at line 153 of file tokenizer\&.c\&.
.SS "\fBToken\fP* \fBcreateToken\fP (\fBTokenType\fPtype, const char *image, const char *fname, unsigned intline)"
Creates a \fBToken\fP structure\&.
.PP
\fBReturns:\fP
.RS 4
A pointer to a \fBToken\fP structure with the desired properties\&.
.RE
.PP
\fBReturn values:\fP
.RS 4
\fINULL\fP malloc was unable to allocate memory\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBdeleteToken(Token *)\fP 
.RE
.PP
\fBNote:\fP
.RS 4
fname is not copied because it would only one copy is stored for all \fBToken\fP structures that share it\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fItype\fP The type of token to create\&. 
.br
\fIimage\fP The characters from the source file that represent the token\&. 
.br
\fIfname\fP A pointer to the name of the file containing the token\&. 
.br
\fIline\fP The line number from the source file that the token occurred on\&. 
.RE
.PP

.PP
Definition at line 100 of file tokenizer\&.c\&.
.SS "void \fBdeleteToken\fP (\fBToken\fP *token)"
Deletes a \fBToken\fP structure\&.
.PP
\fBPrecondition:\fP
.RS 4
\fItoken\fP points to a \fBToken\fP structure created by \fBcreateToken(TokenType, const char *, const char *, unsigned int)\fP\&.
.RE
.PP
\fBPostcondition:\fP
.RS 4
The memory at \fItoken\fP and all of its elements will be freed\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBcreateToken(TokenType, const char *, const char *, unsigned int)\fP 
.RE
.PP

.PP
Definition at line 132 of file tokenizer\&.c\&.
.SS "void \fBdeleteTokens\fP (\fBToken\fP **list)"
Deletes an array of \fBToken\fP structures\&.
.PP
\fBPrecondition:\fP
.RS 4
\fIlist\fP was created by and contains items added by addToken(Token ***, unsigned int *, TokenType, const char *, unsigned int)\&.
.RE
.PP
\fBPostcondition:\fP
.RS 4
The memory at \fIlist\fP and all of its elements will be freed\&.
.RE
.PP
\fBSee also:\fP
.RS 4
addToken(Token ***, unsigned int *, TokenType, const char *, unsigned int) 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlist\fP A pointer to an array of \fBToken\fP structures to be deleted\&. 
.RE
.PP

.PP
Definition at line 179 of file tokenizer\&.c\&.
.SS "int \fBisFloat\fP (const char *image)"
Checks if a string of characters follows the format for a floating point decimal\&. Specifically, it checks if the string of characters matches the regular expression: [-]?[0-9]\&.[0-9]*
.PP
\fBReturn values:\fP
.RS 4
\fI0\fP The string of characters is not a floating point decimal\&. 
.br
\fI1\fP The string of characters is a floating point decimal\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBisInteger(const char *)\fP 
.PP
\fBisString(const char *)\fP 
.PP
\fBisIdentifier(const char *)\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIimage\fP The string of characters to compare\&. 
.RE
.PP

.PP
Definition at line 34 of file tokenizer\&.c\&.
.SS "int \fBisIdentifier\fP (const char *image)"
Checks if a string of characters follows the format for an identifier\&. Specifically, it checks if the string of characters matches the regular expression: [a-zA-Z][a-zA-Z0-9_]*
.PP
\fBReturn values:\fP
.RS 4
\fI0\fP The string of characters is not an identifier\&. 
.br
\fI1\fP The string of characters is an identifier\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBisInteger(const char *)\fP 
.PP
\fBisFloat(const char *)\fP 
.PP
\fBisString(const char *)\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIimage\fP The string of characters to compare\&. 
.RE
.PP

.PP
Definition at line 75 of file tokenizer\&.c\&.
.SS "int \fBisInteger\fP (const char *image)"
Checks if a string of characters follows the format for an integer\&. Specifically, it checks if the string of characters matches the regular expression: [-]?[1-9][0-9]* | 0
.PP
\fBReturn values:\fP
.RS 4
\fI0\fP The string of characters is not an integer\&. 
.br
\fI1\fP The string of characters is an integer\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBisFloat(const char *)\fP 
.PP
\fBisString(const char *)\fP 
.PP
\fBisIdentifier(const char *)\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIimage\fP The string of characters to compare\&. 
.RE
.PP

.PP
Definition at line 13 of file tokenizer\&.c\&.
.SS "\fBToken\fP* \fBisKeyword\fP (\fBLexemeList\fP *lexemes, unsigned int *start)"
Checks if a sequence of lexemes is a keyword\&. \fIlexemes\fP is searched starting at \fIstart\fP for keywords\&. If one is found, the appropriate \fBToken\fP structure is created and returned and the value of \fIstart\fP is incremented by the number of lexemes matched minus one\&.
.PP
\fBPrecondition:\fP
.RS 4
\fIlexemes\fP was created by \fBscanBuffer(const char *, unsigned int, const char *)\fP\&.
.RE
.PP
\fBPostcondition:\fP
.RS 4
If a keyword is not found, \fIstart\fP will be unmodified\&. Otherwise, \fIstart\fP will be incremented by the number of lexemes matched minus one\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A pointer to a newly created keyword \fBToken\fP structure\&.
.RE
.PP
\fBReturn values:\fP
.RS 4
\fINULL\fP No keywords were matched or there was an error allocating memory\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlexemes\fP A pointer to a \fBLexemeList\fP structure to search for keywords in\&. 
.br
\fIstart\fP A pointer to the position within \fIlexemes\fP to start checking at\&. 
.RE
.PP

.PP
Definition at line 229 of file tokenizer\&.c\&.
.SS "int \fBisString\fP (const char *image)"
Checks if a string of characters follows the format for a string\&. Specifically, it checks if the string of characters begins and ends with a quote character\&.
.PP
\fBReturn values:\fP
.RS 4
\fI0\fP The string of characters is not a string\&. 
.br
\fI1\fP The string of characters is a string\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBisInteger(const char *)\fP 
.PP
\fBisFloat(const char *)\fP 
.PP
\fBisIdentifier(const char *)\fP 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIimage\fP The string of characters to compare\&. 
.RE
.PP

.PP
Definition at line 59 of file tokenizer\&.c\&.
.SS "\fBToken\fP** \fBtokenizeLexemes\fP (\fBLexemeList\fP *list)"
Converts a list of lexemes into tokens\&. Additionally parses the literal values of integers, floating point decimals, and strings\&.
.PP
\fBPrecondition:\fP
.RS 4
\fIlist\fP was created by \fBscanBuffer(const char *, unsigned int, const char *)\fP\&.
.RE
.PP
\fBReturns:\fP
.RS 4
A pointer to an array of \fBToken\fP structures representing the tokenized form of the input lexeme stream\&.
.RE
.PP
\fBReturn values:\fP
.RS 4
\fINULL\fP An unrecognized token was encountered or memory allocation failed\&. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIlist\fP A pointer to a \fBLexemeList\fP structure to tokenize\&. 
.RE
.PP

.PP
Definition at line 256 of file tokenizer\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for ResKnife from the source code\&.
